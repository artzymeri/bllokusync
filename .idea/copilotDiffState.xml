<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/PAYMENT_CONFIRMATION_PUSH_NOTIFICATIONS.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PAYMENT_CONFIRMATION_PUSH_NOTIFICATIONS.md" />
              <option name="updatedContent" value="# Payment Confirmation Push Notifications Feature&#10;&#10;## Overview&#10;Push notifications are now sent to tenants when their payments are confirmed, matching the existing email notification functionality.&#10;&#10;## Implementation Summary&#10;&#10;### 1. Push Notification Service Enhancement&#10;**File**: `backend/services/pushNotification.service.js`&#10;&#10;Added a new method `sendPaymentConfirmation()` that sends payment confirmation notifications to tenants:&#10;- **Title**: &quot;✅ Pagesa e Konfirmuar&quot;&#10;- **Body**: &quot;Faleminderit! Pagesa juaj për {month} (€{amount}) është pranuar dhe konfirmuar.&quot;&#10;- **Data payload**: Includes payment details for app navigation&#10;  - type: 'payment_confirmation'&#10;  - month, amount, property, paymentDate&#10;&#10;### 2. Payment Controller Integration&#10;**File**: `backend/controllers/tenantPayment.controller.js`&#10;&#10;#### Single Payment Update (`updatePaymentStatus`)&#10;When a payment is marked as &quot;paid&quot;, the system now:&#10;1. ✅ Sends confirmation email (existing)&#10;2. ✅ Sends push notification (new)&#10;&#10;Both notifications are sent with error handling that won't fail the request if delivery fails.&#10;&#10;#### Bulk Payment Update (`bulkUpdatePayments`)&#10;When multiple payments are marked as &quot;paid&quot;, the system now:&#10;1. ✅ Groups payments by tenant&#10;2. ✅ Sends one email per tenant (existing)&#10;3. ✅ Sends one push notification per tenant (new)&#10;&#10;**Single payment notification**:&#10;- Uses the standard `sendPaymentConfirmation()` method&#10;&#10;**Multiple payments notification**:&#10;- Sends a summary notification with total amount&#10;- Example: &quot;Faleminderit! 3 pagesa tuaja (€450.00) janë pranuar dhe konfirmuar.&quot;&#10;&#10;## Features&#10;&#10;### Payment Confirmation Notifications Include:&#10;- ✅ Payment month&#10;- ✅ Payment amount&#10;- ✅ Property name&#10;- ✅ Payment date&#10;- ✅ Notification type for app routing&#10;&#10;### Error Handling&#10;- Both email and push notifications use try-catch blocks&#10;- Errors are logged but don't fail the payment update request&#10;- Tenants without registered push tokens are handled gracefully&#10;&#10;### Multi-Payment Support&#10;- Single payment: Individual notification with specific details&#10;- Multiple payments: Summary notification with total count and amount&#10;&#10;## Testing&#10;&#10;To test the implementation:&#10;&#10;1. **Single Payment Confirmation**:&#10;   - Mark a tenant payment as &quot;paid&quot; from the property manager dashboard&#10;   - Tenant should receive both email and push notification&#10;&#10;2. **Bulk Payment Confirmation**:&#10;   - Select multiple payments for the same tenant&#10;   - Mark them as &quot;paid&quot; in bulk&#10;   - Tenant should receive one email and one push notification with summary&#10;&#10;3. **Check Logs**:&#10;   - Backend logs will show: `✅ Payment confirmation push notification sent for payment ID: {id}`&#10;   - For bulk: `✅ Multiple payments confirmation push notification sent to tenant {id} for {count} payments`&#10;&#10;## Console Output Examples&#10;&#10;### Single Payment:&#10;```&#10;✅ Payment confirmation email sent for payment ID: 123&#10;✅ Payment confirmation push notification sent for payment ID: 123&#10;```&#10;&#10;### Bulk Payment:&#10;```&#10;✅ Multiple payments confirmation email sent to user@example.com for 3 payments&#10;✅ Multiple payments confirmation push notification sent to tenant 45 for 3 payments&#10;```&#10;&#10;## Mobile App Handling&#10;&#10;The mobile app should already handle these notifications since the push notification infrastructure is in place. The notification data includes:&#10;- `type: 'payment_confirmation'` - for identifying notification type&#10;- Payment details for potential navigation to payment history&#10;&#10;## Notes&#10;&#10;- Push notifications are sent in parallel with emails&#10;- If a tenant doesn't have an active push token, the notification is silently skipped (no error thrown)&#10;- The system uses Expo Push Notification service that's already configured&#10;- Notifications are sent asynchronously and don't block the API response&#10;&#10;## Related Files Modified&#10;&#10;1. `backend/services/pushNotification.service.js` - Added payment confirmation method&#10;2. `backend/controllers/tenantPayment.controller.js` - Integrated push notifications in both single and bulk payment updates&#10;&#10;## Status&#10;&#10;✅ **Implementation Complete** - Ready for testing in production&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/controllers/tenantPayment.controller.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/controllers/tenantPayment.controller.js" />
              <option name="originalContent" value="const db = require('../models');&#10;const { Op, Sequelize } = require('sequelize');&#10;const emailService = require('../services/email.service');&#10;&#10;// Get payments for a specific tenant&#10;exports.getTenantPayments = async (req, res) =&gt; {&#10;  try {&#10;    const { tenantId } = req.params;&#10;    const { property_id, status, year, month } = req.query;&#10;&#10;    // If user is a tenant, they can only access their own payments&#10;    if (req.user.role === 'tenant') {&#10;      if (parseInt(tenantId) !== req.user.id) {&#10;        return res.status(403).json({&#10;          success: false,&#10;          message: 'You can only access your own payment data'&#10;        });&#10;      }&#10;    }&#10;&#10;    const whereClause = { tenant_id: tenantId };&#10;&#10;    if (property_id) {&#10;      whereClause.property_id = property_id;&#10;    }&#10;&#10;    if (status) {&#10;      whereClause.status = status;&#10;    }&#10;&#10;    if (year) {&#10;      const yearNum = parseInt(year);&#10;      if (month) {&#10;        // Check if month is an array (multiple months) or a single value&#10;        const months = Array.isArray(month) ? month : [month];&#10;&#10;        if (months.length &gt; 0) {&#10;          // Create date ranges for each month&#10;          const monthRanges = months.map(m =&gt; {&#10;            const monthNum = parseInt(m) - 1; // month comes as 1-indexed from API&#10;            const startDate = new Date(yearNum, monthNum, 1);&#10;            const endDate = new Date(yearNum, monthNum + 1, 0);&#10;            return {&#10;              [Op.between]: [startDate.toISOString().split('T')[0], endDate.toISOString().split('T')[0]]&#10;            };&#10;          });&#10;&#10;          // Use OR condition for multiple month ranges&#10;          whereClause.payment_month = {&#10;            [Op.or]: monthRanges&#10;          };&#10;        }&#10;      } else {&#10;        const startDate = new Date(yearNum, 0, 1);&#10;        const endDate = new Date(yearNum, 11, 31);&#10;        whereClause.payment_month = {&#10;          [Op.between]: [startDate.toISOString().split('T')[0], endDate.toISOString().split('T')[0]]&#10;        };&#10;      }&#10;    }&#10;&#10;    const payments = await db.TenantPayment.findAll({&#10;      where: whereClause,&#10;      include: [&#10;        {&#10;          model: db.Property,&#10;          as: 'property',&#10;          attributes: ['id', 'name', 'address']&#10;        }&#10;      ],&#10;      order: [['payment_month', 'DESC']]&#10;    });&#10;&#10;    res.json({&#10;      success: true,&#10;      data: payments&#10;    });&#10;  } catch (error) {&#10;    console.error('Get tenant payments error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error fetching tenant payments',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Get payments for property manager's properties&#10;exports.getPropertyManagerPayments = async (req, res) =&gt; {&#10;  try {&#10;    const managerId = req.user.id;&#10;    const { property_id, tenant_id, status, year, month } = req.query;&#10;&#10;    // Get properties managed by this property manager&#10;    const manager = await db.User.findByPk(managerId, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'managedPropertiesMany',&#10;        attributes: ['id'],&#10;        through: { attributes: [] }&#10;      }]&#10;    });&#10;&#10;    if (!manager || !manager.managedPropertiesMany || manager.managedPropertiesMany.length === 0) {&#10;      return res.json({&#10;        success: true,&#10;        data: []&#10;      });&#10;    }&#10;&#10;    const managedPropertyIds = manager.managedPropertiesMany.map(p =&gt; p.id);&#10;&#10;    const whereClause = {&#10;      property_id: { [Op.in]: managedPropertyIds }&#10;    };&#10;&#10;    if (property_id) {&#10;      if (!managedPropertyIds.includes(parseInt(property_id))) {&#10;        return res.status(403).json({&#10;          success: false,&#10;          message: 'You do not manage this property'&#10;        });&#10;      }&#10;      whereClause.property_id = property_id;&#10;    }&#10;&#10;    if (tenant_id) {&#10;      whereClause.tenant_id = tenant_id;&#10;    }&#10;&#10;    if (status) {&#10;      whereClause.status = status;&#10;    }&#10;&#10;    if (year) {&#10;      const yearNum = parseInt(year);&#10;      if (month) {&#10;        // Check if month is an array (multiple months) or a single value&#10;        const months = Array.isArray(month) ? month : [month];&#10;&#10;        if (months.length &gt; 0) {&#10;          // Create date ranges for each month&#10;          const monthRanges = months.map(m =&gt; {&#10;            const monthNum = parseInt(m) - 1; // month comes as 1-indexed from API&#10;            const startDate = new Date(yearNum, monthNum, 1);&#10;            const endDate = new Date(yearNum, monthNum + 1, 0);&#10;            return {&#10;              [Op.between]: [startDate.toISOString().split('T')[0], endDate.toISOString().split('T')[0]]&#10;            };&#10;          });&#10;&#10;          // Use OR condition for multiple month ranges&#10;          whereClause.payment_month = {&#10;            [Op.or]: monthRanges&#10;          };&#10;        }&#10;      } else {&#10;        const startDate = new Date(yearNum, 0, 1);&#10;        const endDate = new Date(yearNum, 11, 31);&#10;        whereClause.payment_month = {&#10;          [Op.between]: [startDate.toISOString().split('T')[0], endDate.toISOString().split('T')[0]]&#10;        };&#10;      }&#10;    }&#10;&#10;    const payments = await db.TenantPayment.findAll({&#10;      where: whereClause,&#10;      include: [&#10;        {&#10;          model: db.User,&#10;          as: 'tenant',&#10;          attributes: ['id', 'name', 'surname', 'email', 'apartment_label']&#10;        },&#10;        {&#10;          model: db.Property,&#10;          as: 'property',&#10;          attributes: ['id', 'name', 'address']&#10;        }&#10;      ],&#10;      order: [['payment_month', 'DESC']]&#10;    });&#10;&#10;    res.json({&#10;      success: true,&#10;      data: payments&#10;    });&#10;  } catch (error) {&#10;    console.error('Get property manager payments error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error fetching payments',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Get payment statistics for property manager&#10;exports.getPaymentStatistics = async (req, res) =&gt; {&#10;  try {&#10;    const managerId = req.user.id;&#10;    const { property_id, year } = req.query;&#10;&#10;    // Get properties managed by this property manager&#10;    const manager = await db.User.findByPk(managerId, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'managedPropertiesMany',&#10;        attributes: ['id'],&#10;        through: { attributes: [] }&#10;      }]&#10;    });&#10;&#10;    if (!manager || !manager.managedPropertiesMany || manager.managedPropertiesMany.length === 0) {&#10;      return res.json({&#10;        success: true,&#10;        data: {&#10;          total: 0,&#10;          paid: 0,&#10;          pending: 0,&#10;          overdue: 0,&#10;          totalAmount: 0,&#10;          paidAmount: 0,&#10;          pendingAmount: 0,&#10;          overdueAmount: 0&#10;        }&#10;      });&#10;    }&#10;&#10;    const managedPropertyIds = manager.managedPropertiesMany.map(p =&gt; p.id);&#10;&#10;    const whereClause = {&#10;      property_id: { [Op.in]: managedPropertyIds }&#10;    };&#10;&#10;    if (property_id) {&#10;      if (!managedPropertyIds.includes(parseInt(property_id))) {&#10;        return res.status(403).json({&#10;          success: false,&#10;          message: 'You do not manage this property'&#10;        });&#10;      }&#10;      whereClause.property_id = property_id;&#10;    }&#10;&#10;    if (year) {&#10;      const yearNum = parseInt(year);&#10;      const startDate = new Date(yearNum, 0, 1);&#10;      const endDate = new Date(yearNum, 11, 31);&#10;      whereClause.payment_month = {&#10;        [Op.between]: [startDate.toISOString().split('T')[0], endDate.toISOString().split('T')[0]]&#10;      };&#10;    }&#10;&#10;    const payments = await db.TenantPayment.findAll({&#10;      where: whereClause,&#10;      attributes: [&#10;        'status',&#10;        [db.sequelize.fn('COUNT', db.sequelize.col('id')), 'count'],&#10;        [db.sequelize.fn('SUM', db.sequelize.col('amount')), 'total']&#10;      ],&#10;      group: ['status'],&#10;      raw: true&#10;    });&#10;&#10;    const stats = {&#10;      total: 0,&#10;      paid: 0,&#10;      pending: 0,&#10;      overdue: 0,&#10;      totalAmount: 0,&#10;      paidAmount: 0,&#10;      pendingAmount: 0,&#10;      overdueAmount: 0&#10;    };&#10;&#10;    payments.forEach(payment =&gt; {&#10;      const count = parseInt(payment.count);&#10;      const total = parseFloat(payment.total || 0);&#10;&#10;      stats.total += count;&#10;      stats.totalAmount += total;&#10;&#10;      switch (payment.status) {&#10;        case 'paid':&#10;          stats.paid = count;&#10;          stats.paidAmount = total;&#10;          break;&#10;        case 'pending':&#10;          stats.pending = count;&#10;          stats.pendingAmount = total;&#10;          break;&#10;        case 'overdue':&#10;          stats.overdue = count;&#10;          stats.overdueAmount = total;&#10;          break;&#10;      }&#10;    });&#10;&#10;    res.json({&#10;      success: true,&#10;      data: stats&#10;    });&#10;  } catch (error) {&#10;    console.error('Get payment statistics error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error fetching payment statistics',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Update payment status&#10;exports.updatePaymentStatus = async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const { status, notes } = req.body;&#10;    const managerId = req.user.id;&#10;&#10;    if (!['pending', 'paid', 'overdue'].includes(status)) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'Invalid status value'&#10;      });&#10;    }&#10;&#10;    const payment = await db.TenantPayment.findByPk(id, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'property'&#10;      }]&#10;    });&#10;&#10;    if (!payment) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'Payment not found'&#10;      });&#10;    }&#10;&#10;    // Check if user manages this property&#10;    const manager = await db.User.findByPk(managerId, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'managedPropertiesMany',&#10;        where: { id: payment.property_id },&#10;        through: { attributes: [] },&#10;        required: false&#10;      }]&#10;    });&#10;&#10;    if (!manager || !manager.managedPropertiesMany || manager.managedPropertiesMany.length === 0) {&#10;      return res.status(403).json({&#10;        success: false,&#10;        message: 'You do not have permission to update this payment'&#10;      });&#10;    }&#10;&#10;    const updateData = { status };&#10;&#10;    if (notes !== undefined) {&#10;      updateData.notes = notes;&#10;    }&#10;&#10;    // Set payment_date when marking as paid&#10;    if (status === 'paid') {&#10;      updateData.payment_date = new Date().toISOString().split('T')[0];&#10;    } else {&#10;      updateData.payment_date = null;&#10;    }&#10;&#10;    await payment.update(updateData);&#10;&#10;    const updatedPayment = await db.TenantPayment.findByPk(id, {&#10;      include: [&#10;        {&#10;          model: db.User,&#10;          as: 'tenant',&#10;          attributes: ['id', 'name', 'surname', 'email', 'apartment_label']&#10;        },&#10;        {&#10;          model: db.Property,&#10;          as: 'property',&#10;          attributes: ['id', 'name', 'address']&#10;        }&#10;      ]&#10;    });&#10;&#10;    // Send email notification if payment was marked as paid&#10;    if (status === 'paid' &amp;&amp; updatedPayment.tenant &amp;&amp; updatedPayment.property) {&#10;      try {&#10;        await emailService.sendSinglePaymentPaidEmail(&#10;          updatedPayment.tenant,&#10;          updatedPayment,&#10;          updatedPayment.property&#10;        );&#10;        console.log(`✅ Payment confirmation email sent for payment ID: ${id}`);&#10;      } catch (emailError) {&#10;        // Log email error but don't fail the request&#10;        console.error('Failed to send payment confirmation email:', emailError.message);&#10;      }&#10;    }&#10;&#10;    res.json({&#10;      success: true,&#10;      message: 'Payment updated successfully',&#10;      data: updatedPayment&#10;    });&#10;  } catch (error) {&#10;    console.error('Update payment status error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error updating payment',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Bulk update payment statuses&#10;exports.bulkUpdatePayments = async (req, res) =&gt; {&#10;  try {&#10;    const { payment_ids, status, notes } = req.body;&#10;    const managerId = req.user.id;&#10;&#10;    if (!payment_ids || !Array.isArray(payment_ids) || payment_ids.length === 0) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'payment_ids array is required'&#10;      });&#10;    }&#10;&#10;    if (!['pending', 'paid', 'overdue'].includes(status)) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'Invalid status value'&#10;      });&#10;    }&#10;&#10;    // Get all payments with tenant and property info&#10;    const payments = await db.TenantPayment.findAll({&#10;      where: { id: { [Op.in]: payment_ids } },&#10;      include: [&#10;        {&#10;          model: db.Property,&#10;          as: 'property',&#10;          attributes: ['id', 'name', 'address']&#10;        },&#10;        {&#10;          model: db.User,&#10;          as: 'tenant',&#10;          attributes: ['id', 'name', 'surname', 'email', 'apartment_label']&#10;        }&#10;      ]&#10;    });&#10;&#10;    if (payments.length === 0) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'No payments found'&#10;      });&#10;    }&#10;&#10;    // Get properties managed by this manager&#10;    const manager = await db.User.findByPk(managerId, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'managedPropertiesMany',&#10;        attributes: ['id'],&#10;        through: { attributes: [] }&#10;      }]&#10;    });&#10;&#10;    const managedPropertyIds = manager.managedPropertiesMany.map(p =&gt; p.id);&#10;&#10;    // Check all payments belong to managed properties&#10;    const unauthorizedPayment = payments.find(p =&gt; !managedPropertyIds.includes(p.property_id));&#10;    if (unauthorizedPayment) {&#10;      return res.status(403).json({&#10;        success: false,&#10;        message: 'You do not have permission to update some of these payments'&#10;      });&#10;    }&#10;&#10;    const updateData = { status };&#10;&#10;    if (notes !== undefined) {&#10;      updateData.notes = notes;&#10;    }&#10;&#10;    if (status === 'paid') {&#10;      updateData.payment_date = new Date().toISOString().split('T')[0];&#10;    } else {&#10;      updateData.payment_date = null;&#10;    }&#10;&#10;    await db.TenantPayment.update(updateData, {&#10;      where: { id: { [Op.in]: payment_ids } }&#10;    });&#10;&#10;    // Send email notifications if payments were marked as paid&#10;    if (status === 'paid') {&#10;      // Group payments by tenant to send one email per tenant&#10;      const paymentsByTenant = {};&#10;&#10;      payments.forEach(payment =&gt; {&#10;        if (payment.tenant &amp;&amp; payment.property) {&#10;          if (!paymentsByTenant[payment.tenant_id]) {&#10;            paymentsByTenant[payment.tenant_id] = {&#10;              tenant: payment.tenant,&#10;              property: payment.property,&#10;              payments: []&#10;            };&#10;          }&#10;          // Update payment with the new payment_date for email&#10;          payment.payment_date = updateData.payment_date;&#10;          payment.notes = notes;&#10;          paymentsByTenant[payment.tenant_id].payments.push(payment);&#10;        }&#10;      });&#10;&#10;      // Send emails to each tenant&#10;      for (const tenantId in paymentsByTenant) {&#10;        const { tenant, property, payments: tenantPayments } = paymentsByTenant[tenantId];&#10;&#10;        try {&#10;          if (tenantPayments.length === 1) {&#10;            // Send single payment email&#10;            await emailService.sendSinglePaymentPaidEmail(tenant, tenantPayments[0], property);&#10;            console.log(`✅ Single payment confirmation email sent to ${tenant.email}`);&#10;          } else {&#10;            // Send multiple payments email&#10;            await emailService.sendMultiplePaymentsPaidEmail(tenant, tenantPayments, property);&#10;            console.log(`✅ Multiple payments confirmation email sent to ${tenant.email} for ${tenantPayments.length} payments`);&#10;          }&#10;        } catch (emailError) {&#10;          // Log email error but don't fail the request&#10;          console.error(`Failed to send payment confirmation email to ${tenant.email}:`, emailError.message);&#10;        }&#10;      }&#10;    }&#10;&#10;    res.json({&#10;      success: true,&#10;      message: `${payment_ids.length} payment(s) updated successfully`&#10;    });&#10;  } catch (error) {&#10;    console.error('Bulk update payments error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error updating payments',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Generate payment records for future months (manual advance payment)&#10;exports.generateFuturePayments = async (req, res) =&gt; {&#10;  try {&#10;    const { tenant_id, property_id, months_ahead } = req.body;&#10;    const managerId = req.user.id;&#10;&#10;    if (!tenant_id || !property_id || !months_ahead) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'tenant_id, property_id, and months_ahead are required'&#10;      });&#10;    }&#10;&#10;    // Check if user manages this property&#10;    const manager = await db.User.findByPk(managerId, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'managedPropertiesMany',&#10;        where: { id: property_id },&#10;        through: { attributes: [] },&#10;        required: false&#10;      }]&#10;    });&#10;&#10;    if (!manager || !manager.managedPropertiesMany || manager.managedPropertiesMany.length === 0) {&#10;      return res.status(403).json({&#10;        success: false,&#10;        message: 'You do not have permission to manage this property'&#10;      });&#10;    }&#10;&#10;    // Get tenant info&#10;    const tenant = await db.User.findOne({&#10;      where: {&#10;        id: tenant_id,&#10;        role: 'tenant',&#10;        [Op.and]: [&#10;          Sequelize.literal(`JSON_CONTAINS(property_ids, '${JSON.stringify([parseInt(property_id)])}')`)&#10;        ]&#10;      }&#10;    });&#10;&#10;    if (!tenant) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'Tenant not found or not associated with this property'&#10;      });&#10;    }&#10;&#10;    if (!tenant.monthly_rate || tenant.monthly_rate &lt;= 0) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'Tenant does not have a monthly rate set'&#10;      });&#10;    }&#10;&#10;    const now = new Date();&#10;    const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);&#10;    const createdPayments = [];&#10;&#10;    for (let i = 0; i &lt; months_ahead; i++) {&#10;      const paymentMonth = new Date(nextMonth);&#10;      paymentMonth.setMonth(paymentMonth.getMonth() + i);&#10;      const monthStr = paymentMonth.toISOString().split('T')[0];&#10;&#10;      // Check if payment already exists&#10;      const [payment, created] = await db.TenantPayment.findOrCreate({&#10;        where: {&#10;          tenant_id,&#10;          property_id,&#10;          payment_month: monthStr&#10;        },&#10;        defaults: {&#10;          amount: tenant.monthly_rate,&#10;          status: 'pending'&#10;        }&#10;      });&#10;&#10;      if (created) {&#10;        createdPayments.push(payment);&#10;      }&#10;    }&#10;&#10;    res.json({&#10;      success: true,&#10;      message: `${createdPayments.length} future payment record(s) created`,&#10;      data: createdPayments&#10;    });&#10;  } catch (error) {&#10;    console.error('Generate future payments error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error generating future payments',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Generate or ensure payment records exist for specific month(s)&#10;exports.ensurePaymentRecords = async (req, res) =&gt; {&#10;  try {&#10;    const { tenant_ids, property_id, year, month } = req.body;&#10;    const managerId = req.user.id;&#10;&#10;    console.log('ensurePaymentRecords called with:', { tenant_ids, property_id, year, month });&#10;&#10;    if (!tenant_ids || !Array.isArray(tenant_ids) || tenant_ids.length === 0) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'tenant_ids array is required'&#10;      });&#10;    }&#10;&#10;    if (!property_id || year === undefined || month === undefined) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'property_id, year, and month are required'&#10;      });&#10;    }&#10;&#10;    // Check if user manages this property&#10;    const manager = await db.User.findByPk(managerId, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'managedPropertiesMany',&#10;        where: { id: property_id },&#10;        through: { attributes: [] },&#10;        required: false&#10;      }]&#10;    });&#10;&#10;    if (!manager || !manager.managedPropertiesMany || manager.managedPropertiesMany.length === 0) {&#10;      return res.status(403).json({&#10;        success: false,&#10;        message: 'You do not have permission to manage this property'&#10;      });&#10;    }&#10;&#10;    // Handle multiple months&#10;    const months = Array.isArray(month) ? month : [month];&#10;&#10;    const createdPayments = [];&#10;    const errors = [];&#10;&#10;    for (const monthIndex of months) {&#10;      // Create payment month date (first day of the month)&#10;      // month is 0-indexed from frontend (0=Jan, 11=Dec), so add 1 for the actual month number&#10;      const monthNumber = monthIndex + 1;&#10;      const monthStr = `${year}-${String(monthNumber).padStart(2, '0')}-01`;&#10;&#10;      console.log('Processing month:', monthStr, 'for month index:', monthIndex);&#10;&#10;      for (const tenantId of tenant_ids) {&#10;        try {&#10;          // Check if ANY payment record already exists for this tenant/property/month&#10;          const existingPayment = await db.TenantPayment.findOne({&#10;            where: {&#10;              tenant_id: tenantId,&#10;              property_id: parseInt(property_id),&#10;              payment_month: monthStr&#10;            }&#10;          });&#10;&#10;          // If payment record exists (regardless of status), just return it and skip creation&#10;          if (existingPayment) {&#10;            console.log('Tenant', tenantId, 'already has payment record for', monthStr, 'with status:', existingPayment.status);&#10;            createdPayments.push({&#10;              id: existingPayment.id,&#10;              tenant_id: tenantId,&#10;              month: monthIndex,&#10;              created: false&#10;            });&#10;            continue;&#10;          }&#10;&#10;          // Get tenant info&#10;          const tenant = await db.User.findOne({&#10;            where: {&#10;              id: tenantId,&#10;              role: 'tenant'&#10;            }&#10;          });&#10;&#10;          console.log('Found tenant:', tenantId, tenant ? `has property_ids: ${tenant.property_ids}` : 'NOT FOUND');&#10;&#10;          if (!tenant) {&#10;            errors.push({ tenant_id: tenantId, month: monthIndex, error: 'Tenant not found' });&#10;            continue;&#10;          }&#10;&#10;          // Check if tenant is associated with this property&#10;          const hasProperty = tenant.property_ids &amp;&amp; tenant.property_ids.includes(parseInt(property_id));&#10;          console.log('Tenant', tenantId, 'has property', property_id, '?', hasProperty);&#10;&#10;          if (!hasProperty) {&#10;            errors.push({ tenant_id: tenantId, month: monthIndex, error: 'Tenant not associated with this property' });&#10;            continue;&#10;          }&#10;&#10;          if (!tenant.monthly_rate || tenant.monthly_rate &lt;= 0) {&#10;            errors.push({ tenant_id: tenantId, month: monthIndex, error: 'Tenant does not have a monthly rate set' });&#10;            continue;&#10;          }&#10;&#10;          console.log('Creating payment record for tenant', tenantId, 'amount:', tenant.monthly_rate, 'month:', monthStr);&#10;&#10;          // Create payment record (we already checked it doesn't exist)&#10;          const payment = await db.TenantPayment.create({&#10;            tenant_id: tenantId,&#10;            property_id: parseInt(property_id),&#10;            payment_month: monthStr,&#10;            amount: tenant.monthly_rate,&#10;            status: 'pending'&#10;          });&#10;&#10;          console.log('Payment record CREATED with ID:', payment.id);&#10;&#10;          createdPayments.push({&#10;            id: payment.id,&#10;            tenant_id: tenantId,&#10;            month: monthIndex,&#10;            created: true&#10;          });&#10;        } catch (err) {&#10;          console.error('Error processing tenant', tenantId, 'for month', monthIndex, ':', err);&#10;          // Check if it's a duplicate key error&#10;          if (err.name === 'SequelizeUniqueConstraintError') {&#10;            // If duplicate, fetch the existing payment and return it&#10;            try {&#10;              const existingPayment = await db.TenantPayment.findOne({&#10;                where: {&#10;                  tenant_id: tenantId,&#10;                  property_id: parseInt(property_id),&#10;                  payment_month: monthStr&#10;                }&#10;              });&#10;              if (existingPayment) {&#10;                createdPayments.push({&#10;                  id: existingPayment.id,&#10;                  tenant_id: tenantId,&#10;                  month: monthIndex,&#10;                  created: false&#10;                });&#10;              }&#10;            } catch (fetchErr) {&#10;              errors.push({ tenant_id: tenantId, month: monthIndex, error: 'Duplicate payment record' });&#10;            }&#10;          } else {&#10;            errors.push({ tenant_id: tenantId, month: monthIndex, error: err.message });&#10;          }&#10;        }&#10;      }&#10;    }&#10;&#10;    console.log('Final result - created:', createdPayments.length, 'errors:', errors.length);&#10;&#10;    res.json({&#10;      success: true,&#10;      message: `Processed ${tenant_ids.length} tenant(s) for ${months.length} month(s)`,&#10;      data: {&#10;        payments: createdPayments,&#10;        new_records: createdPayments.filter(p =&gt; p.created).length,&#10;        existing_records: createdPayments.filter(p =&gt; !p.created).length,&#10;        errors: errors&#10;      }&#10;    });&#10;  } catch (error) {&#10;    console.error('Ensure payment records error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error ensuring payment records',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Update payment date&#10;exports.updatePaymentDate = async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const { payment_date } = req.body;&#10;    const managerId = req.user.id;&#10;&#10;    if (!payment_date) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'payment_date is required'&#10;      });&#10;    }&#10;&#10;    const payment = await db.TenantPayment.findByPk(id, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'property'&#10;      }]&#10;    });&#10;&#10;    if (!payment) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'Payment not found'&#10;      });&#10;    }&#10;&#10;    // Check if user manages this property&#10;    const manager = await db.User.findByPk(managerId, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'managedPropertiesMany',&#10;        where: { id: payment.property_id },&#10;        through: { attributes: [] },&#10;        required: false&#10;      }]&#10;    });&#10;&#10;    if (!manager || !manager.managedPropertiesMany || manager.managedPropertiesMany.length === 0) {&#10;      return res.status(403).json({&#10;        success: false,&#10;        message: 'You do not have permission to update this payment'&#10;      });&#10;    }&#10;&#10;    await payment.update({ payment_date });&#10;&#10;    const updatedPayment = await db.TenantPayment.findByPk(id, {&#10;      include: [&#10;        {&#10;          model: db.User,&#10;          as: 'tenant',&#10;          attributes: ['id', 'name', 'surname', 'email', 'apartment_label']&#10;        },&#10;        {&#10;          model: db.Property,&#10;          as: 'property',&#10;          attributes: ['id', 'name', 'address']&#10;        }&#10;      ]&#10;    });&#10;&#10;    res.json({&#10;      success: true,&#10;      message: 'Payment date updated successfully',&#10;      data: updatedPayment&#10;    });&#10;  } catch (error) {&#10;    console.error('Update payment date error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error updating payment date',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Delete payment record&#10;exports.deletePayment = async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const managerId = req.user.id;&#10;&#10;    const payment = await db.TenantPayment.findByPk(id, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'property'&#10;      }]&#10;    });&#10;&#10;    if (!payment) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'Payment not found'&#10;      });&#10;    }&#10;&#10;    // Check if user manages this property&#10;    const manager = await db.User.findByPk(managerId, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'managedPropertiesMany',&#10;        where: { id: payment.property_id },&#10;        through: { attributes: [] },&#10;        required: false&#10;      }]&#10;    });&#10;&#10;    if (!manager || !manager.managedPropertiesMany || manager.managedPropertiesMany.length === 0) {&#10;      return res.status(403).json({&#10;        success: false,&#10;        message: 'You do not have permission to delete this payment'&#10;      });&#10;    }&#10;&#10;    // Delete the payment&#10;    await payment.destroy();&#10;&#10;    res.json({&#10;      success: true,&#10;      message: 'Payment deleted successfully'&#10;    });&#10;  } catch (error) {&#10;    console.error('Delete payment error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error deleting payment',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;" />
              <option name="updatedContent" value="const db = require('../models');&#10;const { Op, Sequelize } = require('sequelize');&#10;const emailService = require('../services/email.service');&#10;const pushNotificationService = require('../services/pushNotification.service');&#10;&#10;// Get payments for a specific tenant&#10;exports.getTenantPayments = async (req, res) =&gt; {&#10;  try {&#10;    const { tenantId } = req.params;&#10;    const { property_id, status, year, month } = req.query;&#10;&#10;    // If user is a tenant, they can only access their own payments&#10;    if (req.user.role === 'tenant') {&#10;      if (parseInt(tenantId) !== req.user.id) {&#10;        return res.status(403).json({&#10;          success: false,&#10;          message: 'You can only access your own payment data'&#10;        });&#10;      }&#10;    }&#10;&#10;    const whereClause = { tenant_id: tenantId };&#10;&#10;    if (property_id) {&#10;      whereClause.property_id = property_id;&#10;    }&#10;&#10;    if (status) {&#10;      whereClause.status = status;&#10;    }&#10;&#10;    if (year) {&#10;      const yearNum = parseInt(year);&#10;      if (month) {&#10;        // Check if month is an array (multiple months) or a single value&#10;        const months = Array.isArray(month) ? month : [month];&#10;&#10;        if (months.length &gt; 0) {&#10;          // Create date ranges for each month&#10;          const monthRanges = months.map(m =&gt; {&#10;            const monthNum = parseInt(m) - 1; // month comes as 1-indexed from API&#10;            const startDate = new Date(yearNum, monthNum, 1);&#10;            const endDate = new Date(yearNum, monthNum + 1, 0);&#10;            return {&#10;              [Op.between]: [startDate.toISOString().split('T')[0], endDate.toISOString().split('T')[0]]&#10;            };&#10;          });&#10;&#10;          // Use OR condition for multiple month ranges&#10;          whereClause.payment_month = {&#10;            [Op.or]: monthRanges&#10;          };&#10;        }&#10;      } else {&#10;        const startDate = new Date(yearNum, 0, 1);&#10;        const endDate = new Date(yearNum, 11, 31);&#10;        whereClause.payment_month = {&#10;          [Op.between]: [startDate.toISOString().split('T')[0], endDate.toISOString().split('T')[0]]&#10;        };&#10;      }&#10;    }&#10;&#10;    const payments = await db.TenantPayment.findAll({&#10;      where: whereClause,&#10;      include: [&#10;        {&#10;          model: db.Property,&#10;          as: 'property',&#10;          attributes: ['id', 'name', 'address']&#10;        }&#10;      ],&#10;      order: [['payment_month', 'DESC']]&#10;    });&#10;&#10;    res.json({&#10;      success: true,&#10;      data: payments&#10;    });&#10;  } catch (error) {&#10;    console.error('Get tenant payments error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error fetching tenant payments',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Get payments for property manager's properties&#10;exports.getPropertyManagerPayments = async (req, res) =&gt; {&#10;  try {&#10;    const managerId = req.user.id;&#10;    const { property_id, tenant_id, status, year, month } = req.query;&#10;&#10;    // Get properties managed by this property manager&#10;    const manager = await db.User.findByPk(managerId, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'managedPropertiesMany',&#10;        attributes: ['id'],&#10;        through: { attributes: [] }&#10;      }]&#10;    });&#10;&#10;    if (!manager || !manager.managedPropertiesMany || manager.managedPropertiesMany.length === 0) {&#10;      return res.json({&#10;        success: true,&#10;        data: []&#10;      });&#10;    }&#10;&#10;    const managedPropertyIds = manager.managedPropertiesMany.map(p =&gt; p.id);&#10;&#10;    const whereClause = {&#10;      property_id: { [Op.in]: managedPropertyIds }&#10;    };&#10;&#10;    if (property_id) {&#10;      if (!managedPropertyIds.includes(parseInt(property_id))) {&#10;        return res.status(403).json({&#10;          success: false,&#10;          message: 'You do not manage this property'&#10;        });&#10;      }&#10;      whereClause.property_id = property_id;&#10;    }&#10;&#10;    if (tenant_id) {&#10;      whereClause.tenant_id = tenant_id;&#10;    }&#10;&#10;    if (status) {&#10;      whereClause.status = status;&#10;    }&#10;&#10;    if (year) {&#10;      const yearNum = parseInt(year);&#10;      if (month) {&#10;        // Check if month is an array (multiple months) or a single value&#10;        const months = Array.isArray(month) ? month : [month];&#10;&#10;        if (months.length &gt; 0) {&#10;          // Create date ranges for each month&#10;          const monthRanges = months.map(m =&gt; {&#10;            const monthNum = parseInt(m) - 1; // month comes as 1-indexed from API&#10;            const startDate = new Date(yearNum, monthNum, 1);&#10;            const endDate = new Date(yearNum, monthNum + 1, 0);&#10;            return {&#10;              [Op.between]: [startDate.toISOString().split('T')[0], endDate.toISOString().split('T')[0]]&#10;            };&#10;          });&#10;&#10;          // Use OR condition for multiple month ranges&#10;          whereClause.payment_month = {&#10;            [Op.or]: monthRanges&#10;          };&#10;        }&#10;      } else {&#10;        const startDate = new Date(yearNum, 0, 1);&#10;        const endDate = new Date(yearNum, 11, 31);&#10;        whereClause.payment_month = {&#10;          [Op.between]: [startDate.toISOString().split('T')[0], endDate.toISOString().split('T')[0]]&#10;        };&#10;      }&#10;    }&#10;&#10;    const payments = await db.TenantPayment.findAll({&#10;      where: whereClause,&#10;      include: [&#10;        {&#10;          model: db.User,&#10;          as: 'tenant',&#10;          attributes: ['id', 'name', 'surname', 'email', 'apartment_label']&#10;        },&#10;        {&#10;          model: db.Property,&#10;          as: 'property',&#10;          attributes: ['id', 'name', 'address']&#10;        }&#10;      ],&#10;      order: [['payment_month', 'DESC']]&#10;    });&#10;&#10;    res.json({&#10;      success: true,&#10;      data: payments&#10;    });&#10;  } catch (error) {&#10;    console.error('Get property manager payments error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error fetching payments',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Get payment statistics for property manager&#10;exports.getPaymentStatistics = async (req, res) =&gt; {&#10;  try {&#10;    const managerId = req.user.id;&#10;    const { property_id, year } = req.query;&#10;&#10;    // Get properties managed by this property manager&#10;    const manager = await db.User.findByPk(managerId, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'managedPropertiesMany',&#10;        attributes: ['id'],&#10;        through: { attributes: [] }&#10;      }]&#10;    });&#10;&#10;    if (!manager || !manager.managedPropertiesMany || manager.managedPropertiesMany.length === 0) {&#10;      return res.json({&#10;        success: true,&#10;        data: {&#10;          total: 0,&#10;          paid: 0,&#10;          pending: 0,&#10;          overdue: 0,&#10;          totalAmount: 0,&#10;          paidAmount: 0,&#10;          pendingAmount: 0,&#10;          overdueAmount: 0&#10;        }&#10;      });&#10;    }&#10;&#10;    const managedPropertyIds = manager.managedPropertiesMany.map(p =&gt; p.id);&#10;&#10;    const whereClause = {&#10;      property_id: { [Op.in]: managedPropertyIds }&#10;    };&#10;&#10;    if (property_id) {&#10;      if (!managedPropertyIds.includes(parseInt(property_id))) {&#10;        return res.status(403).json({&#10;          success: false,&#10;          message: 'You do not manage this property'&#10;        });&#10;      }&#10;      whereClause.property_id = property_id;&#10;    }&#10;&#10;    if (year) {&#10;      const yearNum = parseInt(year);&#10;      const startDate = new Date(yearNum, 0, 1);&#10;      const endDate = new Date(yearNum, 11, 31);&#10;      whereClause.payment_month = {&#10;        [Op.between]: [startDate.toISOString().split('T')[0], endDate.toISOString().split('T')[0]]&#10;      };&#10;    }&#10;&#10;    const payments = await db.TenantPayment.findAll({&#10;      where: whereClause,&#10;      attributes: [&#10;        'status',&#10;        [db.sequelize.fn('COUNT', db.sequelize.col('id')), 'count'],&#10;        [db.sequelize.fn('SUM', db.sequelize.col('amount')), 'total']&#10;      ],&#10;      group: ['status'],&#10;      raw: true&#10;    });&#10;&#10;    const stats = {&#10;      total: 0,&#10;      paid: 0,&#10;      pending: 0,&#10;      overdue: 0,&#10;      totalAmount: 0,&#10;      paidAmount: 0,&#10;      pendingAmount: 0,&#10;      overdueAmount: 0&#10;    };&#10;&#10;    payments.forEach(payment =&gt; {&#10;      const count = parseInt(payment.count);&#10;      const total = parseFloat(payment.total || 0);&#10;&#10;      stats.total += count;&#10;      stats.totalAmount += total;&#10;&#10;      switch (payment.status) {&#10;        case 'paid':&#10;          stats.paid = count;&#10;          stats.paidAmount = total;&#10;          break;&#10;        case 'pending':&#10;          stats.pending = count;&#10;          stats.pendingAmount = total;&#10;          break;&#10;        case 'overdue':&#10;          stats.overdue = count;&#10;          stats.overdueAmount = total;&#10;          break;&#10;      }&#10;    });&#10;&#10;    res.json({&#10;      success: true,&#10;      data: stats&#10;    });&#10;  } catch (error) {&#10;    console.error('Get payment statistics error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error fetching payment statistics',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Update payment status&#10;exports.updatePaymentStatus = async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const { status, notes } = req.body;&#10;    const managerId = req.user.id;&#10;&#10;    if (!['pending', 'paid', 'overdue'].includes(status)) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'Invalid status value'&#10;      });&#10;    }&#10;&#10;    const payment = await db.TenantPayment.findByPk(id, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'property'&#10;      }]&#10;    });&#10;&#10;    if (!payment) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'Payment not found'&#10;      });&#10;    }&#10;&#10;    // Check if user manages this property&#10;    const manager = await db.User.findByPk(managerId, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'managedPropertiesMany',&#10;        where: { id: payment.property_id },&#10;        through: { attributes: [] },&#10;        required: false&#10;      }]&#10;    });&#10;&#10;    if (!manager || !manager.managedPropertiesMany || manager.managedPropertiesMany.length === 0) {&#10;      return res.status(403).json({&#10;        success: false,&#10;        message: 'You do not have permission to update this payment'&#10;      });&#10;    }&#10;&#10;    const updateData = { status };&#10;&#10;    if (notes !== undefined) {&#10;      updateData.notes = notes;&#10;    }&#10;&#10;    // Set payment_date when marking as paid&#10;    if (status === 'paid') {&#10;      updateData.payment_date = new Date().toISOString().split('T')[0];&#10;    } else {&#10;      updateData.payment_date = null;&#10;    }&#10;&#10;    await payment.update(updateData);&#10;&#10;    const updatedPayment = await db.TenantPayment.findByPk(id, {&#10;      include: [&#10;        {&#10;          model: db.User,&#10;          as: 'tenant',&#10;          attributes: ['id', 'name', 'surname', 'email', 'apartment_label']&#10;        },&#10;        {&#10;          model: db.Property,&#10;          as: 'property',&#10;          attributes: ['id', 'name', 'address']&#10;        }&#10;      ]&#10;    });&#10;&#10;    // Send email notification if payment was marked as paid&#10;    if (status === 'paid' &amp;&amp; updatedPayment.tenant &amp;&amp; updatedPayment.property) {&#10;      try {&#10;        await emailService.sendSinglePaymentPaidEmail(&#10;          updatedPayment.tenant,&#10;          updatedPayment,&#10;          updatedPayment.property&#10;        );&#10;        console.log(`✅ Payment confirmation email sent for payment ID: ${id}`);&#10;      } catch (emailError) {&#10;        // Log email error but don't fail the request&#10;        console.error('Failed to send payment confirmation email:', emailError.message);&#10;      }&#10;&#10;      // Send push notification&#10;      try {&#10;        await pushNotificationService.sendPaymentConfirmation(&#10;          updatedPayment.tenant.id,&#10;          updatedPayment.payment_month,&#10;          updatedPayment.amount,&#10;          updatedPayment.property.name,&#10;          updatedPayment.payment_date&#10;        );&#10;        console.log(`✅ Payment confirmation push notification sent for payment ID: ${id}`);&#10;      } catch (pushError) {&#10;        // Log push notification error but don't fail the request&#10;        console.error('Failed to send payment confirmation push notification:', pushError.message);&#10;      }&#10;    }&#10;&#10;    res.json({&#10;      success: true,&#10;      message: 'Payment updated successfully',&#10;      data: updatedPayment&#10;    });&#10;  } catch (error) {&#10;    console.error('Update payment status error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error updating payment',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Bulk update payment statuses&#10;exports.bulkUpdatePayments = async (req, res) =&gt; {&#10;  try {&#10;    const { payment_ids, status, notes } = req.body;&#10;    const managerId = req.user.id;&#10;&#10;    if (!payment_ids || !Array.isArray(payment_ids) || payment_ids.length === 0) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'payment_ids array is required'&#10;      });&#10;    }&#10;&#10;    if (!['pending', 'paid', 'overdue'].includes(status)) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'Invalid status value'&#10;      });&#10;    }&#10;&#10;    // Get all payments with tenant and property info&#10;    const payments = await db.TenantPayment.findAll({&#10;      where: { id: { [Op.in]: payment_ids } },&#10;      include: [&#10;        {&#10;          model: db.Property,&#10;          as: 'property',&#10;          attributes: ['id', 'name', 'address']&#10;        },&#10;        {&#10;          model: db.User,&#10;          as: 'tenant',&#10;          attributes: ['id', 'name', 'surname', 'email', 'apartment_label']&#10;        }&#10;      ]&#10;    });&#10;&#10;    if (payments.length === 0) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'No payments found'&#10;      });&#10;    }&#10;&#10;    // Get properties managed by this manager&#10;    const manager = await db.User.findByPk(managerId, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'managedPropertiesMany',&#10;        attributes: ['id'],&#10;        through: { attributes: [] }&#10;      }]&#10;    });&#10;&#10;    const managedPropertyIds = manager.managedPropertiesMany.map(p =&gt; p.id);&#10;&#10;    // Check all payments belong to managed properties&#10;    const unauthorizedPayment = payments.find(p =&gt; !managedPropertyIds.includes(p.property_id));&#10;    if (unauthorizedPayment) {&#10;      return res.status(403).json({&#10;        success: false,&#10;        message: 'You do not have permission to update some of these payments'&#10;      });&#10;    }&#10;&#10;    const updateData = { status };&#10;&#10;    if (notes !== undefined) {&#10;      updateData.notes = notes;&#10;    }&#10;&#10;    if (status === 'paid') {&#10;      updateData.payment_date = new Date().toISOString().split('T')[0];&#10;    } else {&#10;      updateData.payment_date = null;&#10;    }&#10;&#10;    await db.TenantPayment.update(updateData, {&#10;      where: { id: { [Op.in]: payment_ids } }&#10;    });&#10;&#10;    // Send email notifications if payments were marked as paid&#10;    if (status === 'paid') {&#10;      // Group payments by tenant to send one email per tenant&#10;      const paymentsByTenant = {};&#10;&#10;      payments.forEach(payment =&gt; {&#10;        if (payment.tenant &amp;&amp; payment.property) {&#10;          if (!paymentsByTenant[payment.tenant_id]) {&#10;            paymentsByTenant[payment.tenant_id] = {&#10;              tenant: payment.tenant,&#10;              property: payment.property,&#10;              payments: []&#10;            };&#10;          }&#10;          // Update payment with the new payment_date for email&#10;          payment.payment_date = updateData.payment_date;&#10;          payment.notes = notes;&#10;          paymentsByTenant[payment.tenant_id].payments.push(payment);&#10;        }&#10;      });&#10;&#10;      // Send emails to each tenant&#10;      for (const tenantId in paymentsByTenant) {&#10;        const { tenant, property, payments: tenantPayments } = paymentsByTenant[tenantId];&#10;&#10;        try {&#10;          if (tenantPayments.length === 1) {&#10;            // Send single payment email&#10;            await emailService.sendSinglePaymentPaidEmail(tenant, tenantPayments[0], property);&#10;            console.log(`✅ Single payment confirmation email sent to ${tenant.email}`);&#10;          } else {&#10;            // Send multiple payments email&#10;            await emailService.sendMultiplePaymentsPaidEmail(tenant, tenantPayments, property);&#10;            console.log(`✅ Multiple payments confirmation email sent to ${tenant.email} for ${tenantPayments.length} payments`);&#10;          }&#10;        } catch (emailError) {&#10;          // Log email error but don't fail the request&#10;          console.error(`Failed to send payment confirmation email to ${tenant.email}:`, emailError.message);&#10;        }&#10;&#10;        // Send push notification for payment confirmation&#10;        try {&#10;          // For multiple payments, send a summary notification&#10;          if (tenantPayments.length === 1) {&#10;            await pushNotificationService.sendPaymentConfirmation(&#10;              tenant.id,&#10;              tenantPayments[0].payment_month,&#10;              tenantPayments[0].amount,&#10;              property.name,&#10;              tenantPayments[0].payment_date&#10;            );&#10;            console.log(`✅ Payment confirmation push notification sent to tenant ${tenant.id}`);&#10;          } else {&#10;            // Send a summary notification for multiple payments&#10;            const totalAmount = tenantPayments.reduce((sum, p) =&gt; sum + parseFloat(p.amount), 0);&#10;            const months = tenantPayments.map(p =&gt; p.payment_month).join(', ');&#10;            await pushNotificationService.sendToUsers(&#10;              [tenant.id],&#10;              '✅ Pagesa e Konfirmuar',&#10;              `Faleminderit! ${tenantPayments.length} pagesa tuaja (€${totalAmount.toFixed(2)}) janë pranuar dhe konfirmuar.`,&#10;              {&#10;                type: 'payment_confirmation',&#10;                count: tenantPayments.length,&#10;                totalAmount: totalAmount,&#10;                property: property.name,&#10;                months: months&#10;              }&#10;            );&#10;            console.log(`✅ Multiple payments confirmation push notification sent to tenant ${tenant.id} for ${tenantPayments.length} payments`);&#10;          }&#10;        } catch (pushError) {&#10;          // Log push notification error but don't fail the request&#10;          console.error(`Failed to send payment confirmation push notification to tenant ${tenant.id}:`, pushError.message);&#10;        }&#10;      }&#10;    }&#10;&#10;    res.json({&#10;      success: true,&#10;      message: `${payment_ids.length} payment(s) updated successfully`&#10;    });&#10;  } catch (error) {&#10;    console.error('Bulk update payments error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error updating payments',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Generate payment records for future months (manual advance payment)&#10;exports.generateFuturePayments = async (req, res) =&gt; {&#10;  try {&#10;    const { tenant_id, property_id, months_ahead } = req.body;&#10;    const managerId = req.user.id;&#10;&#10;    if (!tenant_id || !property_id || !months_ahead) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'tenant_id, property_id, and months_ahead are required'&#10;      });&#10;    }&#10;&#10;    // Check if user manages this property&#10;    const manager = await db.User.findByPk(managerId, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'managedPropertiesMany',&#10;        where: { id: property_id },&#10;        through: { attributes: [] },&#10;        required: false&#10;      }]&#10;    });&#10;&#10;    if (!manager || !manager.managedPropertiesMany || manager.managedPropertiesMany.length === 0) {&#10;      return res.status(403).json({&#10;        success: false,&#10;        message: 'You do not have permission to manage this property'&#10;      });&#10;    }&#10;&#10;    // Get tenant info&#10;    const tenant = await db.User.findOne({&#10;      where: {&#10;        id: tenant_id,&#10;        role: 'tenant',&#10;        [Op.and]: [&#10;          Sequelize.literal(`JSON_CONTAINS(property_ids, '${JSON.stringify([parseInt(property_id)])}')`)&#10;        ]&#10;      }&#10;    });&#10;&#10;    if (!tenant) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'Tenant not found or not associated with this property'&#10;      });&#10;    }&#10;&#10;    if (!tenant.monthly_rate || tenant.monthly_rate &lt;= 0) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'Tenant does not have a monthly rate set'&#10;      });&#10;    }&#10;&#10;    const now = new Date();&#10;    const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);&#10;    const createdPayments = [];&#10;&#10;    for (let i = 0; i &lt; months_ahead; i++) {&#10;      const paymentMonth = new Date(nextMonth);&#10;      paymentMonth.setMonth(paymentMonth.getMonth() + i);&#10;      const monthStr = paymentMonth.toISOString().split('T')[0];&#10;&#10;      // Check if payment already exists&#10;      const [payment, created] = await db.TenantPayment.findOrCreate({&#10;        where: {&#10;          tenant_id,&#10;          property_id,&#10;          payment_month: monthStr&#10;        },&#10;        defaults: {&#10;          amount: tenant.monthly_rate,&#10;          status: 'pending'&#10;        }&#10;      });&#10;&#10;      if (created) {&#10;        createdPayments.push(payment);&#10;      }&#10;    }&#10;&#10;    res.json({&#10;      success: true,&#10;      message: `${createdPayments.length} future payment record(s) created`,&#10;      data: createdPayments&#10;    });&#10;  } catch (error) {&#10;    console.error('Generate future payments error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error generating future payments',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Generate or ensure payment records exist for specific month(s)&#10;exports.ensurePaymentRecords = async (req, res) =&gt; {&#10;  try {&#10;    const { tenant_ids, property_id, year, month } = req.body;&#10;    const managerId = req.user.id;&#10;&#10;    console.log('ensurePaymentRecords called with:', { tenant_ids, property_id, year, month });&#10;&#10;    if (!tenant_ids || !Array.isArray(tenant_ids) || tenant_ids.length === 0) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'tenant_ids array is required'&#10;      });&#10;    }&#10;&#10;    if (!property_id || year === undefined || month === undefined) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'property_id, year, and month are required'&#10;      });&#10;    }&#10;&#10;    // Check if user manages this property&#10;    const manager = await db.User.findByPk(managerId, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'managedPropertiesMany',&#10;        where: { id: property_id },&#10;        through: { attributes: [] },&#10;        required: false&#10;      }]&#10;    });&#10;&#10;    if (!manager || !manager.managedPropertiesMany || manager.managedPropertiesMany.length === 0) {&#10;      return res.status(403).json({&#10;        success: false,&#10;        message: 'You do not have permission to manage this property'&#10;      });&#10;    }&#10;&#10;    // Handle multiple months&#10;    const months = Array.isArray(month) ? month : [month];&#10;&#10;    const createdPayments = [];&#10;    const errors = [];&#10;&#10;    for (const monthIndex of months) {&#10;      // Create payment month date (first day of the month)&#10;      // month is 0-indexed from frontend (0=Jan, 11=Dec), so add 1 for the actual month number&#10;      const monthNumber = monthIndex + 1;&#10;      const monthStr = `${year}-${String(monthNumber).padStart(2, '0')}-01`;&#10;&#10;      console.log('Processing month:', monthStr, 'for month index:', monthIndex);&#10;&#10;      for (const tenantId of tenant_ids) {&#10;        try {&#10;          // Check if ANY payment record already exists for this tenant/property/month&#10;          const existingPayment = await db.TenantPayment.findOne({&#10;            where: {&#10;              tenant_id: tenantId,&#10;              property_id: parseInt(property_id),&#10;              payment_month: monthStr&#10;            }&#10;          });&#10;&#10;          // If payment record exists (regardless of status), just return it and skip creation&#10;          if (existingPayment) {&#10;            console.log('Tenant', tenantId, 'already has payment record for', monthStr, 'with status:', existingPayment.status);&#10;            createdPayments.push({&#10;              id: existingPayment.id,&#10;              tenant_id: tenantId,&#10;              month: monthIndex,&#10;              created: false&#10;            });&#10;            continue;&#10;          }&#10;&#10;          // Get tenant info&#10;          const tenant = await db.User.findOne({&#10;            where: {&#10;              id: tenantId,&#10;              role: 'tenant'&#10;            }&#10;          });&#10;&#10;          console.log('Found tenant:', tenantId, tenant ? `has property_ids: ${tenant.property_ids}` : 'NOT FOUND');&#10;&#10;          if (!tenant) {&#10;            errors.push({ tenant_id: tenantId, month: monthIndex, error: 'Tenant not found' });&#10;            continue;&#10;          }&#10;&#10;          // Check if tenant is associated with this property&#10;          const hasProperty = tenant.property_ids &amp;&amp; tenant.property_ids.includes(parseInt(property_id));&#10;          console.log('Tenant', tenantId, 'has property', property_id, '?', hasProperty);&#10;&#10;          if (!hasProperty) {&#10;            errors.push({ tenant_id: tenantId, month: monthIndex, error: 'Tenant not associated with this property' });&#10;            continue;&#10;          }&#10;&#10;          if (!tenant.monthly_rate || tenant.monthly_rate &lt;= 0) {&#10;            errors.push({ tenant_id: tenantId, month: monthIndex, error: 'Tenant does not have a monthly rate set' });&#10;            continue;&#10;          }&#10;&#10;          console.log('Creating payment record for tenant', tenantId, 'amount:', tenant.monthly_rate, 'month:', monthStr);&#10;&#10;          // Create payment record (we already checked it doesn't exist)&#10;          const payment = await db.TenantPayment.create({&#10;            tenant_id: tenantId,&#10;            property_id: parseInt(property_id),&#10;            payment_month: monthStr,&#10;            amount: tenant.monthly_rate,&#10;            status: 'pending'&#10;          });&#10;&#10;          console.log('Payment record CREATED with ID:', payment.id);&#10;&#10;          createdPayments.push({&#10;            id: payment.id,&#10;            tenant_id: tenantId,&#10;            month: monthIndex,&#10;            created: true&#10;          });&#10;        } catch (err) {&#10;          console.error('Error processing tenant', tenantId, 'for month', monthIndex, ':', err);&#10;          // Check if it's a duplicate key error&#10;          if (err.name === 'SequelizeUniqueConstraintError') {&#10;            // If duplicate, fetch the existing payment and return it&#10;            try {&#10;              const existingPayment = await db.TenantPayment.findOne({&#10;                where: {&#10;                  tenant_id: tenantId,&#10;                  property_id: parseInt(property_id),&#10;                  payment_month: monthStr&#10;                }&#10;              });&#10;              if (existingPayment) {&#10;                createdPayments.push({&#10;                  id: existingPayment.id,&#10;                  tenant_id: tenantId,&#10;                  month: monthIndex,&#10;                  created: false&#10;                });&#10;              }&#10;            } catch (fetchErr) {&#10;              errors.push({ tenant_id: tenantId, month: monthIndex, error: 'Duplicate payment record' });&#10;            }&#10;          } else {&#10;            errors.push({ tenant_id: tenantId, month: monthIndex, error: err.message });&#10;          }&#10;        }&#10;      }&#10;    }&#10;&#10;    console.log('Final result - created:', createdPayments.length, 'errors:', errors.length);&#10;&#10;    res.json({&#10;      success: true,&#10;      message: `Processed ${tenant_ids.length} tenant(s) for ${months.length} month(s)`,&#10;      data: {&#10;        payments: createdPayments,&#10;        new_records: createdPayments.filter(p =&gt; p.created).length,&#10;        existing_records: createdPayments.filter(p =&gt; !p.created).length,&#10;        errors: errors&#10;      }&#10;    });&#10;  } catch (error) {&#10;    console.error('Ensure payment records error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error ensuring payment records',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Update payment date&#10;exports.updatePaymentDate = async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const { payment_date } = req.body;&#10;    const managerId = req.user.id;&#10;&#10;    if (!payment_date) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'payment_date is required'&#10;      });&#10;    }&#10;&#10;    const payment = await db.TenantPayment.findByPk(id, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'property'&#10;      }]&#10;    });&#10;&#10;    if (!payment) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'Payment not found'&#10;      });&#10;    }&#10;&#10;    // Check if user manages this property&#10;    const manager = await db.User.findByPk(managerId, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'managedPropertiesMany',&#10;        where: { id: payment.property_id },&#10;        through: { attributes: [] },&#10;        required: false&#10;      }]&#10;    });&#10;&#10;    if (!manager || !manager.managedPropertiesMany || manager.managedPropertiesMany.length === 0) {&#10;      return res.status(403).json({&#10;        success: false,&#10;        message: 'You do not have permission to update this payment'&#10;      });&#10;    }&#10;&#10;    await payment.update({ payment_date });&#10;&#10;    const updatedPayment = await db.TenantPayment.findByPk(id, {&#10;      include: [&#10;        {&#10;          model: db.User,&#10;          as: 'tenant',&#10;          attributes: ['id', 'name', 'surname', 'email', 'apartment_label']&#10;        },&#10;        {&#10;          model: db.Property,&#10;          as: 'property',&#10;          attributes: ['id', 'name', 'address']&#10;        }&#10;      ]&#10;    });&#10;&#10;    res.json({&#10;      success: true,&#10;      message: 'Payment date updated successfully',&#10;      data: updatedPayment&#10;    });&#10;  } catch (error) {&#10;    console.error('Update payment date error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error updating payment date',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Delete payment record&#10;exports.deletePayment = async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const managerId = req.user.id;&#10;&#10;    const payment = await db.TenantPayment.findByPk(id, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'property'&#10;      }]&#10;    });&#10;&#10;    if (!payment) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'Payment not found'&#10;      });&#10;    }&#10;&#10;    // Check if user manages this property&#10;    const manager = await db.User.findByPk(managerId, {&#10;      include: [{&#10;        model: db.Property,&#10;        as: 'managedPropertiesMany',&#10;        where: { id: payment.property_id },&#10;        through: { attributes: [] },&#10;        required: false&#10;      }]&#10;    });&#10;&#10;    if (!manager || !manager.managedPropertiesMany || manager.managedPropertiesMany.length === 0) {&#10;      return res.status(403).json({&#10;        success: false,&#10;        message: 'You do not have permission to delete this payment'&#10;      });&#10;    }&#10;&#10;    // Delete the payment&#10;    await payment.destroy();&#10;&#10;    res.json({&#10;      success: true,&#10;      message: 'Payment deleted successfully'&#10;    });&#10;  } catch (error) {&#10;    console.error('Delete payment error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error deleting payment',&#10;      error: error.message&#10;    });&#10;  }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/investigate_arber_erjona.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/investigate_arber_erjona.js" />
              <option name="updatedContent" value="const db = require('./models');&#10;const { Op } = require('sequelize');&#10;&#10;async function investigateTenantVisibility() {&#10;  try {&#10;    console.log('=== STEP-BY-STEP INVESTIGATION: Why Arber Cannot See Erjona ===\n');&#10;&#10;    // STEP 1: Verify Arber's property manager setup&#10;    console.log('STEP 1: Check Arber Halili (Property Manager)');&#10;    const arber = await db.User.findOne({&#10;      where: { email: 'arberhalili@gmail.com' }&#10;    });&#10;    console.log('  - ID:', arber.id);&#10;    console.log('  - Name:', arber.name, arber.surname);&#10;    console.log('  - Role:', arber.role);&#10;    console.log('  - property_ids field (legacy):', arber.property_ids);&#10;&#10;    // STEP 2: Check properties assigned to Arber via junction table&#10;    console.log('\nSTEP 2: Check properties assigned to Arber via junction table');&#10;    const arberProperties = await db.PropertyManager.findAll({&#10;      where: { user_id: arber.id },&#10;      attributes: ['property_id']&#10;    });&#10;    const arberPropertyIds = arberProperties.map(p =&gt; p.property_id);&#10;    console.log('  - Managed Property IDs:', arberPropertyIds);&#10;&#10;    // STEP 3: Verify Erjona's tenant setup&#10;    console.log('\nSTEP 3: Check Erjona Berisha (Tenant)');&#10;    const erjona = await db.User.findOne({&#10;      where: { email: 'jona@gmail.com' }&#10;    });&#10;    console.log('  - ID:', erjona.id);&#10;    console.log('  - Name:', erjona.name, erjona.surname);&#10;    console.log('  - Role:', erjona.role);&#10;    console.log('  - property_ids field:', erjona.property_ids);&#10;    console.log('  - property_ids type:', typeof erjona.property_ids);&#10;    console.log('  - property_ids raw:', JSON.stringify(erjona.property_ids));&#10;&#10;    // STEP 4: Test if property 3 is in the overlap&#10;    console.log('\nSTEP 4: Check if property 3 is in both lists');&#10;    const hasProperty3 = arberPropertyIds.includes(3);&#10;    const erjonaHasProperty3 = erjona.property_ids &amp;&amp; erjona.property_ids.includes(3);&#10;    console.log('  - Arber manages property 3?', hasProperty3);&#10;    console.log('  - Erjona assigned to property 3?', erjonaHasProperty3);&#10;&#10;    // STEP 5: Test the LIKE query (current implementation)&#10;    console.log('\nSTEP 5: Test LIKE query for property 3');&#10;    const likeQuery = {&#10;      role: 'tenant',&#10;      [Op.or]: arberPropertyIds.map(propId =&gt; ({&#10;        property_ids: {&#10;          [Op.like]: `%${propId}%`&#10;        }&#10;      }))&#10;    };&#10;    console.log('  - Query:', JSON.stringify(likeQuery, null, 2));&#10;    &#10;    const likeResults = await db.User.findAll({&#10;      where: likeQuery,&#10;      attributes: ['id', 'name', 'surname', 'email', 'property_ids']&#10;    });&#10;    console.log('  - Results count:', likeResults.length);&#10;    console.log('  - Results:', likeResults.map(t =&gt; ({&#10;      id: t.id,&#10;      name: `${t.name} ${t.surname}`,&#10;      email: t.email,&#10;      property_ids: t.property_ids&#10;    })));&#10;&#10;    // STEP 6: Test with JSON_CONTAINS (proper MySQL JSON function)&#10;    console.log('\nSTEP 6: Test JSON_CONTAINS for property 3 specifically');&#10;    const jsonContainsResults = await db.sequelize.query(&#10;      `SELECT id, name, surname, email, property_ids &#10;       FROM users &#10;       WHERE role = 'tenant' &#10;       AND JSON_CONTAINS(property_ids, '3', '$')`,&#10;      { type: db.sequelize.QueryTypes.SELECT }&#10;    );&#10;    console.log('  - JSON_CONTAINS Results:', jsonContainsResults);&#10;&#10;    // STEP 7: Test with all property IDs&#10;    console.log('\nSTEP 7: Test JSON_CONTAINS with all of Arber\'s property IDs');&#10;    for (const propId of arberPropertyIds) {&#10;      const results = await db.sequelize.query(&#10;        `SELECT id, name, surname, email, property_ids &#10;         FROM users &#10;         WHERE role = 'tenant' &#10;         AND JSON_CONTAINS(property_ids, '${propId}', '$')`,&#10;        { type: db.sequelize.QueryTypes.SELECT }&#10;      );&#10;      console.log(`  - Tenants with property ${propId}:`, results.map(r =&gt; r.name));&#10;    }&#10;&#10;    // STEP 8: Check the actual SQL generated by Sequelize&#10;    console.log('\nSTEP 8: Check Sequelize SQL generation');&#10;    const { count, rows } = await db.User.findAndCountAll({&#10;      where: likeQuery,&#10;      attributes: { exclude: ['password'] },&#10;      limit: 10,&#10;      offset: 0,&#10;      logging: console.log // This will print the SQL query&#10;    });&#10;    console.log('  - Count:', count);&#10;    console.log('  - Rows:', rows.length);&#10;&#10;    console.log('\n=== INVESTIGATION COMPLETE ===');&#10;    process.exit(0);&#10;  } catch (error) {&#10;    console.error('Error during investigation:', error);&#10;    process.exit(1);&#10;  }&#10;}&#10;&#10;investigateTenantVisibility();&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/services/pushNotification.service.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/services/pushNotification.service.js" />
              <option name="originalContent" value="const { Expo } = require('expo-server-sdk');&#10;const db = require('../models');&#10;&#10;class PushNotificationService {&#10;  constructor() {&#10;    // Create a new Expo SDK client&#10;    this.expo = new Expo();&#10;  }&#10;&#10;  /**&#10;   * Send push notification to specific users&#10;   */&#10;  async sendToUsers(userIds, title, body, data = {}) {&#10;    try {&#10;      // Get all active push tokens for these users&#10;      const pushTokens = await db.PushToken.findAll({&#10;        where: {&#10;          user_id: userIds,&#10;          is_active: true&#10;        }&#10;      });&#10;&#10;      if (pushTokens.length === 0) {&#10;        console.log('No active push tokens found for users:', userIds);&#10;        return { success: true, sent: 0 };&#10;      }&#10;&#10;      const messages = [];&#10;      &#10;      for (const tokenRecord of pushTokens) {&#10;        // Check that the token is a valid Expo push token&#10;        if (!Expo.isExpoPushToken(tokenRecord.push_token)) {&#10;          console.error(`Push token ${tokenRecord.push_token} is not a valid Expo push token`);&#10;          continue;&#10;        }&#10;&#10;        messages.push({&#10;          to: tokenRecord.push_token,&#10;          sound: 'default',&#10;          title: title,&#10;          body: body,&#10;          data: data,&#10;          priority: 'high',&#10;        });&#10;      }&#10;&#10;      // Send notifications in chunks (Expo recommends batching)&#10;      const chunks = this.expo.chunkPushNotifications(messages);&#10;      const tickets = [];&#10;&#10;      for (const chunk of chunks) {&#10;        try {&#10;          const ticketChunk = await this.expo.sendPushNotificationsAsync(chunk);&#10;          tickets.push(...ticketChunk);&#10;        } catch (error) {&#10;          console.error('Error sending push notification chunk:', error);&#10;        }&#10;      }&#10;&#10;      console.log(`✅ Sent ${messages.length} push notifications`);&#10;      return { success: true, sent: messages.length, tickets };&#10;&#10;    } catch (error) {&#10;      console.error('Error sending push notifications:', error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Send payment reminder notification&#10;   */&#10;  async sendPaymentReminder(userId, monthName, amount, propertyName) {&#10;    return await this.sendToUsers(&#10;      [userId],&#10;      ' Kujtesë Pagese',&#10;      `Pagesa juaj për ${monthName} (€${amount}) në ${propertyName} po afron. Ju lutemi sigurohuni që të paguani në kohë.`,&#10;      {&#10;        type: 'payment_reminder',&#10;        month: monthName,&#10;        amount: amount,&#10;        property: propertyName&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Send complaint/report status update notification&#10;   */&#10;  async sendStatusUpdate(userId, type, status, title) {&#10;    const typeText = type === 'complaint' ? 'Ankesa' : type === 'report' ? 'Raporti' : 'Sugjerimi';&#10;    const statusText = status === 'resolved' ? 'u zgjidh' : status === 'in_progress' ? 'është në proces' : 'u përditësua';&#10;    &#10;    return await this.sendToUsers(&#10;      [userId],&#10;      ` ${typeText} u Përditësua`,&#10;      `${typeText} juaj &quot;${title}&quot; ${statusText}.`,&#10;      {&#10;        type: 'status_update',&#10;        itemType: type,&#10;        status: status&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Send new monthly report notification&#10;   */&#10;  async sendMonthlyReportNotification(userIds, monthName, propertyName) {&#10;    return await this.sendToUsers(&#10;      userIds,&#10;      ' Raport i Ri Mujor',&#10;      `Raporti mujor për ${monthName} në ${propertyName} është gati për t'u parë.`,&#10;      {&#10;        type: 'monthly_report',&#10;        month: monthName,&#10;        property: propertyName&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Send welcome notification to new user&#10;   */&#10;  async sendWelcomeNotification(userId, userName) {&#10;    return await this.sendToUsers(&#10;      [userId],&#10;      ' Mirë se erdhe në BllokuSync!',&#10;      `Përshëndetje ${userName}! Llogaria juaj është miratuar dhe jeni gati të filloni.`,&#10;      {&#10;        type: 'welcome'&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Check notification receipts (to see if they were delivered)&#10;   */&#10;  async checkReceipts(tickets) {&#10;    const receiptIds = tickets&#10;      .filter(ticket =&gt; ticket.id)&#10;      .map(ticket =&gt; ticket.id);&#10;&#10;    if (receiptIds.length === 0) {&#10;      return [];&#10;    }&#10;&#10;    const receiptIdChunks = this.expo.chunkPushNotificationReceiptIds(receiptIds);&#10;    const receipts = [];&#10;&#10;    for (const chunk of receiptIdChunks) {&#10;      try {&#10;        const receiptChunk = await this.expo.getPushNotificationReceiptsAsync(chunk);&#10;        receipts.push(receiptChunk);&#10;&#10;        // Check for errors&#10;        for (const receiptId in receiptChunk) {&#10;          const receipt = receiptChunk[receiptId];&#10;          &#10;          if (receipt.status === 'error') {&#10;            console.error(`Error in receipt ${receiptId}:`, receipt.message);&#10;            &#10;            // Handle specific errors (like DeviceNotRegistered)&#10;            if (receipt.details &amp;&amp; receipt.details.error === 'DeviceNotRegistered') {&#10;              // TODO: Remove this push token from database&#10;              console.log('Device not registered, should remove token');&#10;            }&#10;          }&#10;        }&#10;      } catch (error) {&#10;        console.error('Error fetching receipts:', error);&#10;      }&#10;    }&#10;&#10;    return receipts;&#10;  }&#10;&#10;  /**&#10;   * Clean up invalid/expired tokens&#10;   */&#10;  async cleanupInvalidTokens() {&#10;    // This should be called periodically to remove tokens that are no longer valid&#10;    // You can implement this based on receipt errors&#10;    console.log('Cleaning up invalid push tokens...');&#10;  }&#10;}&#10;&#10;module.exports = new PushNotificationService();&#10;&#10;" />
              <option name="updatedContent" value="const { Expo } = require('expo-server-sdk');&#10;const db = require('../models');&#10;&#10;class PushNotificationService {&#10;  constructor() {&#10;    // Create a new Expo SDK client&#10;    this.expo = new Expo();&#10;  }&#10;&#10;  /**&#10;   * Send push notification to specific users&#10;   */&#10;  async sendToUsers(userIds, title, body, data = {}) {&#10;    try {&#10;      // Get all active push tokens for these users&#10;      const pushTokens = await db.PushToken.findAll({&#10;        where: {&#10;          user_id: userIds,&#10;          is_active: true&#10;        }&#10;      });&#10;&#10;      if (pushTokens.length === 0) {&#10;        console.log('No active push tokens found for users:', userIds);&#10;        return { success: true, sent: 0 };&#10;      }&#10;&#10;      const messages = [];&#10;      &#10;      for (const tokenRecord of pushTokens) {&#10;        // Check that the token is a valid Expo push token&#10;        if (!Expo.isExpoPushToken(tokenRecord.push_token)) {&#10;          console.error(`Push token ${tokenRecord.push_token} is not a valid Expo push token`);&#10;          continue;&#10;        }&#10;&#10;        messages.push({&#10;          to: tokenRecord.push_token,&#10;          sound: 'default',&#10;          title: title,&#10;          body: body,&#10;          data: data,&#10;          priority: 'high',&#10;        });&#10;      }&#10;&#10;      // Send notifications in chunks (Expo recommends batching)&#10;      const chunks = this.expo.chunkPushNotifications(messages);&#10;      const tickets = [];&#10;&#10;      for (const chunk of chunks) {&#10;        try {&#10;          const ticketChunk = await this.expo.sendPushNotificationsAsync(chunk);&#10;          tickets.push(...ticketChunk);&#10;        } catch (error) {&#10;          console.error('Error sending push notification chunk:', error);&#10;        }&#10;      }&#10;&#10;      console.log(`✅ Sent ${messages.length} push notifications`);&#10;      return { success: true, sent: messages.length, tickets };&#10;&#10;    } catch (error) {&#10;      console.error('Error sending push notifications:', error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Send payment reminder notification&#10;   */&#10;  async sendPaymentReminder(userId, monthName, amount, propertyName) {&#10;    return await this.sendToUsers(&#10;      [userId],&#10;      ' Kujtesë Pagese',&#10;      `Pagesa juaj për ${monthName} (€${amount}) në ${propertyName} po afron. Ju lutemi sigurohuni që të paguani në kohë.`,&#10;      {&#10;        type: 'payment_reminder',&#10;        month: monthName,&#10;        amount: amount,&#10;        property: propertyName&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Send payment confirmation notification&#10;   */&#10;  async sendPaymentConfirmation(userId, monthName, amount, propertyName, paymentDate) {&#10;    return await this.sendToUsers(&#10;      [userId],&#10;      '✅ Pagesa e Konfirmuar',&#10;      `Faleminderit! Pagesa juaj për ${monthName} (€${amount}) është pranuar dhe konfirmuar.`,&#10;      {&#10;        type: 'payment_confirmation',&#10;        month: monthName,&#10;        amount: amount,&#10;        property: propertyName,&#10;        paymentDate: paymentDate&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Send complaint/report status update notification&#10;   */&#10;  async sendStatusUpdate(userId, type, status, title) {&#10;    const typeText = type === 'complaint' ? 'Ankesa' : type === 'report' ? 'Raporti' : 'Sugjerimi';&#10;    const statusText = status === 'resolved' ? 'u zgjidh' : status === 'in_progress' ? 'është në proces' : 'u përditësua';&#10;    &#10;    return await this.sendToUsers(&#10;      [userId],&#10;      ` ${typeText} u Përditësua`,&#10;      `${typeText} juaj &quot;${title}&quot; ${statusText}.`,&#10;      {&#10;        type: 'status_update',&#10;        itemType: type,&#10;        status: status&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Send new monthly report notification&#10;   */&#10;  async sendMonthlyReportNotification(userIds, monthName, propertyName) {&#10;    return await this.sendToUsers(&#10;      userIds,&#10;      ' Raport i Ri Mujor',&#10;      `Raporti mujor për ${monthName} në ${propertyName} është gati për t'u parë.`,&#10;      {&#10;        type: 'monthly_report',&#10;        month: monthName,&#10;        property: propertyName&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Send welcome notification to new user&#10;   */&#10;  async sendWelcomeNotification(userId, userName) {&#10;    return await this.sendToUsers(&#10;      [userId],&#10;      ' Mirë se erdhe në BllokuSync!',&#10;      `Përshëndetje ${userName}! Llogaria juaj është miratuar dhe jeni gati të filloni.`,&#10;      {&#10;        type: 'welcome'&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Check notification receipts (to see if they were delivered)&#10;   */&#10;  async checkReceipts(tickets) {&#10;    const receiptIds = tickets&#10;      .filter(ticket =&gt; ticket.id)&#10;      .map(ticket =&gt; ticket.id);&#10;&#10;    if (receiptIds.length === 0) {&#10;      return [];&#10;    }&#10;&#10;    const receiptIdChunks = this.expo.chunkPushNotificationReceiptIds(receiptIds);&#10;    const receipts = [];&#10;&#10;    for (const chunk of receiptIdChunks) {&#10;      try {&#10;        const receiptChunk = await this.expo.getPushNotificationReceiptsAsync(chunk);&#10;        receipts.push(receiptChunk);&#10;&#10;        // Check for errors&#10;        for (const receiptId in receiptChunk) {&#10;          const receipt = receiptChunk[receiptId];&#10;          &#10;          if (receipt.status === 'error') {&#10;            console.error(`Error in receipt ${receiptId}:`, receipt.message);&#10;            &#10;            // Handle specific errors (like DeviceNotRegistered)&#10;            if (receipt.details &amp;&amp; receipt.details.error === 'DeviceNotRegistered') {&#10;              // TODO: Remove this push token from database&#10;              console.log('Device not registered, should remove token');&#10;            }&#10;          }&#10;        }&#10;      } catch (error) {&#10;        console.error('Error fetching receipts:', error);&#10;      }&#10;    }&#10;&#10;    return receipts;&#10;  }&#10;&#10;  /**&#10;   * Clean up invalid/expired tokens&#10;   */&#10;  async cleanupInvalidTokens() {&#10;    // This should be called periodically to remove tokens that are no longer valid&#10;    // You can implement this based on receipt errors&#10;    console.log('Cleaning up invalid push tokens...');&#10;  }&#10;}&#10;&#10;module.exports = new PushNotificationService();" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>