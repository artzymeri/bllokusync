<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/investigate_arber_erjona.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/investigate_arber_erjona.js" />
              <option name="updatedContent" value="const db = require('./models');&#10;const { Op } = require('sequelize');&#10;&#10;async function investigateTenantVisibility() {&#10;  try {&#10;    console.log('=== STEP-BY-STEP INVESTIGATION: Why Arber Cannot See Erjona ===\n');&#10;&#10;    // STEP 1: Verify Arber's property manager setup&#10;    console.log('STEP 1: Check Arber Halili (Property Manager)');&#10;    const arber = await db.User.findOne({&#10;      where: { email: 'arberhalili@gmail.com' }&#10;    });&#10;    console.log('  - ID:', arber.id);&#10;    console.log('  - Name:', arber.name, arber.surname);&#10;    console.log('  - Role:', arber.role);&#10;    console.log('  - property_ids field (legacy):', arber.property_ids);&#10;&#10;    // STEP 2: Check properties assigned to Arber via junction table&#10;    console.log('\nSTEP 2: Check properties assigned to Arber via junction table');&#10;    const arberProperties = await db.PropertyManager.findAll({&#10;      where: { user_id: arber.id },&#10;      attributes: ['property_id']&#10;    });&#10;    const arberPropertyIds = arberProperties.map(p =&gt; p.property_id);&#10;    console.log('  - Managed Property IDs:', arberPropertyIds);&#10;&#10;    // STEP 3: Verify Erjona's tenant setup&#10;    console.log('\nSTEP 3: Check Erjona Berisha (Tenant)');&#10;    const erjona = await db.User.findOne({&#10;      where: { email: 'jona@gmail.com' }&#10;    });&#10;    console.log('  - ID:', erjona.id);&#10;    console.log('  - Name:', erjona.name, erjona.surname);&#10;    console.log('  - Role:', erjona.role);&#10;    console.log('  - property_ids field:', erjona.property_ids);&#10;    console.log('  - property_ids type:', typeof erjona.property_ids);&#10;    console.log('  - property_ids raw:', JSON.stringify(erjona.property_ids));&#10;&#10;    // STEP 4: Test if property 3 is in the overlap&#10;    console.log('\nSTEP 4: Check if property 3 is in both lists');&#10;    const hasProperty3 = arberPropertyIds.includes(3);&#10;    const erjonaHasProperty3 = erjona.property_ids &amp;&amp; erjona.property_ids.includes(3);&#10;    console.log('  - Arber manages property 3?', hasProperty3);&#10;    console.log('  - Erjona assigned to property 3?', erjonaHasProperty3);&#10;&#10;    // STEP 5: Test the LIKE query (current implementation)&#10;    console.log('\nSTEP 5: Test LIKE query for property 3');&#10;    const likeQuery = {&#10;      role: 'tenant',&#10;      [Op.or]: arberPropertyIds.map(propId =&gt; ({&#10;        property_ids: {&#10;          [Op.like]: `%${propId}%`&#10;        }&#10;      }))&#10;    };&#10;    console.log('  - Query:', JSON.stringify(likeQuery, null, 2));&#10;    &#10;    const likeResults = await db.User.findAll({&#10;      where: likeQuery,&#10;      attributes: ['id', 'name', 'surname', 'email', 'property_ids']&#10;    });&#10;    console.log('  - Results count:', likeResults.length);&#10;    console.log('  - Results:', likeResults.map(t =&gt; ({&#10;      id: t.id,&#10;      name: `${t.name} ${t.surname}`,&#10;      email: t.email,&#10;      property_ids: t.property_ids&#10;    })));&#10;&#10;    // STEP 6: Test with JSON_CONTAINS (proper MySQL JSON function)&#10;    console.log('\nSTEP 6: Test JSON_CONTAINS for property 3 specifically');&#10;    const jsonContainsResults = await db.sequelize.query(&#10;      `SELECT id, name, surname, email, property_ids &#10;       FROM users &#10;       WHERE role = 'tenant' &#10;       AND JSON_CONTAINS(property_ids, '3', '$')`,&#10;      { type: db.sequelize.QueryTypes.SELECT }&#10;    );&#10;    console.log('  - JSON_CONTAINS Results:', jsonContainsResults);&#10;&#10;    // STEP 7: Test with all property IDs&#10;    console.log('\nSTEP 7: Test JSON_CONTAINS with all of Arber\'s property IDs');&#10;    for (const propId of arberPropertyIds) {&#10;      const results = await db.sequelize.query(&#10;        `SELECT id, name, surname, email, property_ids &#10;         FROM users &#10;         WHERE role = 'tenant' &#10;         AND JSON_CONTAINS(property_ids, '${propId}', '$')`,&#10;        { type: db.sequelize.QueryTypes.SELECT }&#10;      );&#10;      console.log(`  - Tenants with property ${propId}:`, results.map(r =&gt; r.name));&#10;    }&#10;&#10;    // STEP 8: Check the actual SQL generated by Sequelize&#10;    console.log('\nSTEP 8: Check Sequelize SQL generation');&#10;    const { count, rows } = await db.User.findAndCountAll({&#10;      where: likeQuery,&#10;      attributes: { exclude: ['password'] },&#10;      limit: 10,&#10;      offset: 0,&#10;      logging: console.log // This will print the SQL query&#10;    });&#10;    console.log('  - Count:', count);&#10;    console.log('  - Rows:', rows.length);&#10;&#10;    console.log('\n=== INVESTIGATION COMPLETE ===');&#10;    process.exit(0);&#10;  } catch (error) {&#10;    console.error('Error during investigation:', error);&#10;    process.exit(1);&#10;  }&#10;}&#10;&#10;investigateTenantVisibility();&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/services/pushNotification.service.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/services/pushNotification.service.js" />
              <option name="originalContent" value="const { Expo } = require('expo-server-sdk');&#10;const db = require('../models');&#10;&#10;class PushNotificationService {&#10;  constructor() {&#10;    // Create a new Expo SDK client&#10;    this.expo = new Expo();&#10;  }&#10;&#10;  /**&#10;   * Send push notification to specific users&#10;   */&#10;  async sendToUsers(userIds, title, body, data = {}) {&#10;    try {&#10;      // Get all active push tokens for these users&#10;      const pushTokens = await db.PushToken.findAll({&#10;        where: {&#10;          user_id: userIds,&#10;          is_active: true&#10;        }&#10;      });&#10;&#10;      if (pushTokens.length === 0) {&#10;        console.log('No active push tokens found for users:', userIds);&#10;        return { success: true, sent: 0 };&#10;      }&#10;&#10;      const messages = [];&#10;      &#10;      for (const tokenRecord of pushTokens) {&#10;        // Check that the token is a valid Expo push token&#10;        if (!Expo.isExpoPushToken(tokenRecord.push_token)) {&#10;          console.error(`Push token ${tokenRecord.push_token} is not a valid Expo push token`);&#10;          continue;&#10;        }&#10;&#10;        messages.push({&#10;          to: tokenRecord.push_token,&#10;          sound: 'default',&#10;          title: title,&#10;          body: body,&#10;          data: data,&#10;          priority: 'high',&#10;        });&#10;      }&#10;&#10;      // Send notifications in chunks (Expo recommends batching)&#10;      const chunks = this.expo.chunkPushNotifications(messages);&#10;      const tickets = [];&#10;&#10;      for (const chunk of chunks) {&#10;        try {&#10;          const ticketChunk = await this.expo.sendPushNotificationsAsync(chunk);&#10;          tickets.push(...ticketChunk);&#10;        } catch (error) {&#10;          console.error('Error sending push notification chunk:', error);&#10;        }&#10;      }&#10;&#10;      console.log(`✅ Sent ${messages.length} push notifications`);&#10;      return { success: true, sent: messages.length, tickets };&#10;&#10;    } catch (error) {&#10;      console.error('Error sending push notifications:', error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Send payment reminder notification&#10;   */&#10;  async sendPaymentReminder(userId, monthName, amount, propertyName) {&#10;    return await this.sendToUsers(&#10;      [userId],&#10;      ' Kujtesë Pagese',&#10;      `Pagesa juaj për ${monthName} (€${amount}) në ${propertyName} po afron. Ju lutemi sigurohuni që të paguani në kohë.`,&#10;      {&#10;        type: 'payment_reminder',&#10;        month: monthName,&#10;        amount: amount,&#10;        property: propertyName&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Send payment confirmation notification&#10;   */&#10;  async sendPaymentConfirmation(userId, monthName, amount, propertyName, paymentDate) {&#10;    return await this.sendToUsers(&#10;      [userId],&#10;      '✅ Pagesa e Konfirmuar',&#10;      `Faleminderit! Pagesa juaj për ${monthName} (€${amount}) është pranuar dhe konfirmuar.`,&#10;      {&#10;        type: 'payment_confirmation',&#10;        month: monthName,&#10;        amount: amount,&#10;        property: propertyName,&#10;        paymentDate: paymentDate&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Send complaint/report status update notification&#10;   */&#10;  async sendStatusUpdate(userId, type, status, title) {&#10;    const typeText = type === 'complaint' ? 'Ankesa' : type === 'report' ? 'Raporti' : 'Sugjerimi';&#10;    const statusText = status === 'resolved' ? 'u zgjidh' : status === 'in_progress' ? 'është në proces' : 'u përditësua';&#10;    &#10;    return await this.sendToUsers(&#10;      [userId],&#10;      ` ${typeText} u Përditësua`,&#10;      `${typeText} juaj &quot;${title}&quot; ${statusText}.`,&#10;      {&#10;        type: 'status_update',&#10;        itemType: type,&#10;        status: status&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Send new monthly report notification&#10;   */&#10;  async sendMonthlyReportNotification(userIds, monthName, propertyName) {&#10;    return await this.sendToUsers(&#10;      userIds,&#10;      ' Raport i Ri Mujor',&#10;      `Raporti mujor për ${monthName} në ${propertyName} është gati për t'u parë.`,&#10;      {&#10;        type: 'monthly_report',&#10;        month: monthName,&#10;        property: propertyName&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Send welcome notification to new user&#10;   */&#10;  async sendWelcomeNotification(userId, userName) {&#10;    return await this.sendToUsers(&#10;      [userId],&#10;      ' Mirë se erdhe në BllokuSync!',&#10;      `Përshëndetje ${userName}! Llogaria juaj është miratuar dhe jeni gati të filloni.`,&#10;      {&#10;        type: 'welcome'&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Check notification receipts (to see if they were delivered)&#10;   */&#10;  async checkReceipts(tickets) {&#10;    const receiptIds = tickets&#10;      .filter(ticket =&gt; ticket.id)&#10;      .map(ticket =&gt; ticket.id);&#10;&#10;    if (receiptIds.length === 0) {&#10;      return [];&#10;    }&#10;&#10;    const receiptIdChunks = this.expo.chunkPushNotificationReceiptIds(receiptIds);&#10;    const receipts = [];&#10;&#10;    for (const chunk of receiptIdChunks) {&#10;      try {&#10;        const receiptChunk = await this.expo.getPushNotificationReceiptsAsync(chunk);&#10;        receipts.push(receiptChunk);&#10;&#10;        // Check for errors&#10;        for (const receiptId in receiptChunk) {&#10;          const receipt = receiptChunk[receiptId];&#10;          &#10;          if (receipt.status === 'error') {&#10;            console.error(`Error in receipt ${receiptId}:`, receipt.message);&#10;            &#10;            // Handle specific errors (like DeviceNotRegistered)&#10;            if (receipt.details &amp;&amp; receipt.details.error === 'DeviceNotRegistered') {&#10;              // TODO: Remove this push token from database&#10;              console.log('Device not registered, should remove token');&#10;            }&#10;          }&#10;        }&#10;      } catch (error) {&#10;        console.error('Error fetching receipts:', error);&#10;      }&#10;    }&#10;&#10;    return receipts;&#10;  }&#10;&#10;  /**&#10;   * Clean up invalid/expired tokens&#10;   */&#10;  async cleanupInvalidTokens() {&#10;    // This should be called periodically to remove tokens that are no longer valid&#10;    // You can implement this based on receipt errors&#10;    console.log('Cleaning up invalid push tokens...');&#10;  }&#10;}&#10;&#10;module.exports = new PushNotificationService();&#10;" />
              <option name="updatedContent" value="const { Expo } = require('expo-server-sdk');&#10;const db = require('../models');&#10;&#10;class PushNotificationService {&#10;  constructor() {&#10;    // Create a new Expo SDK client&#10;    this.expo = new Expo();&#10;  }&#10;&#10;  /**&#10;   * Send push notification to specific users&#10;   */&#10;  async sendToUsers(userIds, title, body, data = {}) {&#10;    try {&#10;      // Get all active push tokens for these users&#10;      const pushTokens = await db.PushToken.findAll({&#10;        where: {&#10;          user_id: userIds,&#10;          is_active: true&#10;        }&#10;      });&#10;&#10;      if (pushTokens.length === 0) {&#10;        console.log('No active push tokens found for users:', userIds);&#10;        return { success: true, sent: 0 };&#10;      }&#10;&#10;      const messages = [];&#10;      &#10;      for (const tokenRecord of pushTokens) {&#10;        // Check that the token is a valid Expo push token&#10;        if (!Expo.isExpoPushToken(tokenRecord.push_token)) {&#10;          console.error(`Push token ${tokenRecord.push_token} is not a valid Expo push token`);&#10;          continue;&#10;        }&#10;&#10;        messages.push({&#10;          to: tokenRecord.push_token,&#10;          sound: 'default',&#10;          title: title,&#10;          body: body,&#10;          data: data,&#10;          priority: 'high',&#10;          channelId: data.type === 'payment_confirmation' ? 'payment_confirmations' : &#10;                     data.type === 'payment_reminder' ? 'payment_reminders' : 'default',&#10;          badge: 1,&#10;        });&#10;      }&#10;&#10;      // Send notifications in chunks (Expo recommends batching)&#10;      const chunks = this.expo.chunkPushNotifications(messages);&#10;      const tickets = [];&#10;&#10;      for (const chunk of chunks) {&#10;        try {&#10;          const ticketChunk = await this.expo.sendPushNotificationsAsync(chunk);&#10;          tickets.push(...ticketChunk);&#10;        } catch (error) {&#10;          console.error('Error sending push notification chunk:', error);&#10;        }&#10;      }&#10;&#10;      console.log(`✅ Sent ${messages.length} push notifications`);&#10;      return { success: true, sent: messages.length, tickets };&#10;&#10;    } catch (error) {&#10;      console.error('Error sending push notifications:', error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Send payment reminder notification&#10;   */&#10;  async sendPaymentReminder(userId, monthName, amount, propertyName) {&#10;    return await this.sendToUsers(&#10;      [userId],&#10;      ' Kujtesë Pagese',&#10;      `Pagesa juaj për ${monthName} (€${amount}) në ${propertyName} po afron. Ju lutemi sigurohuni që të paguani në kohë.`,&#10;      {&#10;        type: 'payment_reminder',&#10;        month: monthName,&#10;        amount: amount,&#10;        property: propertyName&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Send payment confirmation notification&#10;   */&#10;  async sendPaymentConfirmation(userId, monthName, amount, propertyName, paymentDate) {&#10;    return await this.sendToUsers(&#10;      [userId],&#10;      '✅ Pagesa e Konfirmuar',&#10;      `Faleminderit! Pagesa juaj për ${monthName} (€${amount}) është pranuar dhe konfirmuar.`,&#10;      {&#10;        type: 'payment_confirmation',&#10;        month: monthName,&#10;        amount: amount,&#10;        property: propertyName,&#10;        paymentDate: paymentDate&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Send complaint/report status update notification&#10;   */&#10;  async sendStatusUpdate(userId, type, status, title) {&#10;    const typeText = type === 'complaint' ? 'Ankesa' : type === 'report' ? 'Raporti' : 'Sugjerimi';&#10;    const statusText = status === 'resolved' ? 'u zgjidh' : status === 'in_progress' ? 'është në proces' : 'u përditësua';&#10;    &#10;    return await this.sendToUsers(&#10;      [userId],&#10;      ` ${typeText} u Përditësua`,&#10;      `${typeText} juaj &quot;${title}&quot; ${statusText}.`,&#10;      {&#10;        type: 'status_update',&#10;        itemType: type,&#10;        status: status&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Send new monthly report notification&#10;   */&#10;  async sendMonthlyReportNotification(userIds, monthName, propertyName) {&#10;    return await this.sendToUsers(&#10;      userIds,&#10;      ' Raport i Ri Mujor',&#10;      `Raporti mujor për ${monthName} në ${propertyName} është gati për t'u parë.`,&#10;      {&#10;        type: 'monthly_report',&#10;        month: monthName,&#10;        property: propertyName&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Send welcome notification to new user&#10;   */&#10;  async sendWelcomeNotification(userId, userName) {&#10;    return await this.sendToUsers(&#10;      [userId],&#10;      ' Mirë se erdhe në BllokuSync!',&#10;      `Përshëndetje ${userName}! Llogaria juaj është miratuar dhe jeni gati të filloni.`,&#10;      {&#10;        type: 'welcome'&#10;      }&#10;    );&#10;  }&#10;&#10;  /**&#10;   * Check notification receipts (to see if they were delivered)&#10;   */&#10;  async checkReceipts(tickets) {&#10;    const receiptIds = tickets&#10;      .filter(ticket =&gt; ticket.id)&#10;      .map(ticket =&gt; ticket.id);&#10;&#10;    if (receiptIds.length === 0) {&#10;      return [];&#10;    }&#10;&#10;    const receiptIdChunks = this.expo.chunkPushNotificationReceiptIds(receiptIds);&#10;    const receipts = [];&#10;&#10;    for (const chunk of receiptIdChunks) {&#10;      try {&#10;        const receiptChunk = await this.expo.getPushNotificationReceiptsAsync(chunk);&#10;        receipts.push(receiptChunk);&#10;&#10;        // Check for errors&#10;        for (const receiptId in receiptChunk) {&#10;          const receipt = receiptChunk[receiptId];&#10;          &#10;          if (receipt.status === 'error') {&#10;            console.error(`Error in receipt ${receiptId}:`, receipt.message);&#10;            &#10;            // Handle specific errors (like DeviceNotRegistered)&#10;            if (receipt.details &amp;&amp; receipt.details.error === 'DeviceNotRegistered') {&#10;              // TODO: Remove this push token from database&#10;              console.log('Device not registered, should remove token');&#10;            }&#10;          }&#10;        }&#10;      } catch (error) {&#10;        console.error('Error fetching receipts:', error);&#10;      }&#10;    }&#10;&#10;    return receipts;&#10;  }&#10;&#10;  /**&#10;   * Clean up invalid/expired tokens&#10;   */&#10;  async cleanupInvalidTokens() {&#10;    // This should be called periodically to remove tokens that are no longer valid&#10;    // You can implement this based on receipt errors&#10;    console.log('Cleaning up invalid push tokens...');&#10;  }&#10;}&#10;&#10;module.exports = new PushNotificationService();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/mobile/app.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/mobile/app.json" />
              <option name="originalContent" value="{&#10;  &quot;expo&quot;: {&#10;    &quot;name&quot;: &quot;BllokuSync&quot;,&#10;    &quot;slug&quot;: &quot;bllokusync-mobile&quot;,&#10;    &quot;version&quot;: &quot;1.0.0&quot;,&#10;    &quot;orientation&quot;: &quot;portrait&quot;,&#10;    &quot;userInterfaceStyle&quot;: &quot;light&quot;,&#10;    &quot;splash&quot;: {&#10;      &quot;resizeMode&quot;: &quot;contain&quot;,&#10;      &quot;backgroundColor&quot;: &quot;#ffffff&quot;&#10;    },&#10;    &quot;ios&quot;: {&#10;      &quot;supportsTablet&quot;: true,&#10;      &quot;bundleIdentifier&quot;: &quot;com.bllokusync.mobile&quot;&#10;    },&#10;    &quot;android&quot;: {&#10;      &quot;package&quot;: &quot;com.bllokusync.mobile&quot;&#10;    },&#10;    &quot;web&quot;: {}&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;expo&quot;: {&#10;    &quot;name&quot;: &quot;BllokuSync&quot;,&#10;    &quot;slug&quot;: &quot;bllokusync-mobile&quot;,&#10;    &quot;version&quot;: &quot;1.0.0&quot;,&#10;    &quot;orientation&quot;: &quot;portrait&quot;,&#10;    &quot;userInterfaceStyle&quot;: &quot;light&quot;,&#10;    &quot;icon&quot;: &quot;./assets/app_logo.png&quot;,&#10;    &quot;splash&quot;: {&#10;      &quot;image&quot;: &quot;./assets/app_logo.png&quot;,&#10;      &quot;resizeMode&quot;: &quot;contain&quot;,&#10;      &quot;backgroundColor&quot;: &quot;#ffffff&quot;&#10;    },&#10;    &quot;notification&quot;: {&#10;      &quot;icon&quot;: &quot;./assets/app_logo.png&quot;,&#10;      &quot;color&quot;: &quot;#3b82f6&quot;,&#10;      &quot;androidMode&quot;: &quot;default&quot;,&#10;      &quot;androidCollapsedTitle&quot;: &quot;BllokuSync&quot;&#10;    },&#10;    &quot;ios&quot;: {&#10;      &quot;supportsTablet&quot;: true,&#10;      &quot;bundleIdentifier&quot;: &quot;com.bllokusync.mobile&quot;,&#10;      &quot;infoPlist&quot;: {&#10;        &quot;UIBackgroundModes&quot;: [&#10;          &quot;remote-notification&quot;&#10;        ],&#10;        &quot;NSUserNotificationsUsageDescription&quot;: &quot;BllokuSync needs notification permissions to send you payment confirmations, payment reminders, and important updates about your property.&quot;&#10;      }&#10;    },&#10;    &quot;android&quot;: {&#10;      &quot;package&quot;: &quot;com.bllokusync.mobile&quot;,&#10;      &quot;adaptiveIcon&quot;: {&#10;        &quot;foregroundImage&quot;: &quot;./assets/app_logo.png&quot;,&#10;        &quot;backgroundColor&quot;: &quot;#ffffff&quot;&#10;      },&#10;      &quot;permissions&quot;: [&#10;        &quot;NOTIFICATIONS&quot;,&#10;        &quot;RECEIVE_BOOT_COMPLETED&quot;,&#10;        &quot;VIBRATE&quot;&#10;      ],&#10;      &quot;useNextNotificationsApi&quot;: true&#10;    },&#10;    &quot;plugins&quot;: [&#10;      [&#10;        &quot;expo-notifications&quot;,&#10;        {&#10;          &quot;icon&quot;: &quot;./assets/app_logo.png&quot;,&#10;          &quot;color&quot;: &quot;#3b82f6&quot;,&#10;          &quot;sounds&quot;: [&#10;            &quot;./assets/notification.wav&quot;&#10;          ],&#10;          &quot;defaultChannel&quot;: &quot;default&quot;&#10;        }&#10;      ]&#10;    ],&#10;    &quot;web&quot;: {}&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/mobile/src/services/pushNotificationService.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/mobile/src/services/pushNotificationService.js" />
              <option name="originalContent" value="import * as Device from 'expo-device';&#10;import * as Notifications from 'expo-notifications';&#10;import { Platform } from 'react-native';&#10;import AsyncStorage from '@react-native-async-storage/async-storage';&#10;&#10;const API_URL = 'http://192.168.1.100:5000/api'; // Update with your API URL&#10;&#10;// Configure notification handler&#10;Notifications.setNotificationHandler({&#10;  handleNotification: async () =&gt; ({&#10;    shouldShowAlert: true,&#10;    shouldPlaySound: true,&#10;    shouldSetBadge: true,&#10;  }),&#10;});&#10;&#10;class PushNotificationService {&#10;  /**&#10;   * Register for push notifications and get Expo Push Token&#10;   */&#10;  async registerForPushNotifications() {&#10;    let token;&#10;&#10;    if (Platform.OS === 'android') {&#10;      await Notifications.setNotificationChannelAsync('default', {&#10;        name: 'default',&#10;        importance: Notifications.AndroidImportance.MAX,&#10;        vibrationPattern: [0, 250, 250, 250],&#10;        lightColor: '#667eea',&#10;      });&#10;    }&#10;&#10;    if (Device.isDevice) {&#10;      const { status: existingStatus } = await Notifications.getPermissionsAsync();&#10;      let finalStatus = existingStatus;&#10;      &#10;      if (existingStatus !== 'granted') {&#10;        const { status } = await Notifications.requestPermissionsAsync();&#10;        finalStatus = status;&#10;      }&#10;      &#10;      if (finalStatus !== 'granted') {&#10;        console.log('Failed to get push token for push notification!');&#10;        return null;&#10;      }&#10;      &#10;      token = (await Notifications.getExpoPushTokenAsync()).data;&#10;      console.log('Push token obtained:', token);&#10;    } else {&#10;      console.log('Must use physical device for Push Notifications');&#10;      return null;&#10;    }&#10;&#10;    return token;&#10;  }&#10;&#10;  /**&#10;   * Save push token to backend&#10;   */&#10;  async savePushToken(token, authToken) {&#10;    try {&#10;      const response = await fetch(`${API_URL}/push-tokens`, {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;          'Authorization': `Bearer ${authToken}`,&#10;        },&#10;        body: JSON.stringify({&#10;          push_token: token,&#10;          device_type: Platform.OS,&#10;        }),&#10;      });&#10;&#10;      const data = await response.json();&#10;      &#10;      if (data.success) {&#10;        console.log('Push token saved to backend');&#10;        await AsyncStorage.setItem('push_token', token);&#10;      } else {&#10;        console.error('Failed to save push token:', data.message);&#10;      }&#10;&#10;      return data;&#10;    } catch (error) {&#10;      console.error('Error saving push token:', error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Remove push token from backend (on logout)&#10;   */&#10;  async removePushToken(authToken) {&#10;    try {&#10;      const token = await AsyncStorage.getItem('push_token');&#10;      if (!token) return;&#10;&#10;      const response = await fetch(`${API_URL}/push-tokens`, {&#10;        method: 'DELETE',&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;          'Authorization': `Bearer ${authToken}`,&#10;        },&#10;        body: JSON.stringify({&#10;          push_token: token,&#10;        }),&#10;      });&#10;&#10;      const data = await response.json();&#10;      &#10;      if (data.success) {&#10;        console.log('Push token removed from backend');&#10;        await AsyncStorage.removeItem('push_token');&#10;      }&#10;&#10;      return data;&#10;    } catch (error) {&#10;      console.error('Error removing push token:', error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Setup notification listeners&#10;   */&#10;  setupNotificationListeners(onNotificationReceived, onNotificationTapped) {&#10;    // Listener for notifications received while app is in foreground&#10;    const notificationListener = Notifications.addNotificationReceivedListener(notification =&gt; {&#10;      console.log('Notification received:', notification);&#10;      if (onNotificationReceived) {&#10;        onNotificationReceived(notification);&#10;      }&#10;    });&#10;&#10;    // Listener for when user taps on notification&#10;    const responseListener = Notifications.addNotificationResponseReceivedListener(response =&gt; {&#10;      console.log('Notification tapped:', response);&#10;      if (onNotificationTapped) {&#10;        onNotificationTapped(response);&#10;      }&#10;    });&#10;&#10;    return {&#10;      notificationListener,&#10;      responseListener,&#10;    };&#10;  }&#10;&#10;  /**&#10;   * Remove notification listeners&#10;   */&#10;  removeNotificationListeners(listeners) {&#10;    if (listeners.notificationListener) {&#10;      Notifications.removeNotificationSubscription(listeners.notificationListener);&#10;    }&#10;    if (listeners.responseListener) {&#10;      Notifications.removeNotificationSubscription(listeners.responseListener);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Schedule a local notification (for testing)&#10;   */&#10;  async scheduleLocalNotification(title, body, data = {}, seconds = 1) {&#10;    await Notifications.scheduleNotificationAsync({&#10;      content: {&#10;        title,&#10;        body,&#10;        data,&#10;        sound: true,&#10;      },&#10;      trigger: { seconds },&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Get notification permissions status&#10;   */&#10;  async getPermissionsStatus() {&#10;    const { status } = await Notifications.getPermissionsAsync();&#10;    return status;&#10;  }&#10;&#10;  /**&#10;   * Request notification permissions&#10;   */&#10;  async requestPermissions() {&#10;    const { status } = await Notifications.requestPermissionsAsync();&#10;    return status;&#10;  }&#10;}&#10;&#10;export default new PushNotificationService();&#10;&#10;" />
              <option name="updatedContent" value="import * as Device from 'expo-device';&#10;import * as Notifications from 'expo-notifications';&#10;import { Platform } from 'react-native';&#10;import AsyncStorage from '@react-native-async-storage/async-storage';&#10;&#10;const API_URL = 'http://192.168.1.100:5000/api'; // Update with your API URL&#10;&#10;// Configure notification handler&#10;Notifications.setNotificationHandler({&#10;  handleNotification: async () =&gt; ({&#10;    shouldShowAlert: true,&#10;    shouldPlaySound: true,&#10;    shouldSetBadge: true,&#10;  }),&#10;});&#10;&#10;class PushNotificationService {&#10;  /**&#10;   * Register for push notifications and get Expo Push Token&#10;   */&#10;  async registerForPushNotifications() {&#10;    let token;&#10;&#10;    if (Platform.OS === 'android') {&#10;      await Notifications.setNotificationChannelAsync('default', {&#10;        name: 'default',&#10;        importance: Notifications.AndroidImportance.MAX,&#10;        vibrationPattern: [0, 250, 250, 250],&#10;        lightColor: '#3b82f6',&#10;        sound: 'default',&#10;        enableVibrate: true,&#10;        enableLights: true,&#10;        showBadge: true,&#10;      });&#10;      &#10;      // Create additional channels for different notification types&#10;      await Notifications.setNotificationChannelAsync('payment_confirmations', {&#10;        name: 'Payment Confirmations',&#10;        importance: Notifications.AndroidImportance.HIGH,&#10;        vibrationPattern: [0, 250, 250, 250],&#10;        lightColor: '#10b981',&#10;        sound: 'default',&#10;        enableVibrate: true,&#10;        showBadge: true,&#10;      });&#10;      &#10;      await Notifications.setNotificationChannelAsync('payment_reminders', {&#10;        name: 'Payment Reminders',&#10;        importance: Notifications.AndroidImportance.HIGH,&#10;        vibrationPattern: [0, 250, 250, 250],&#10;        lightColor: '#f59e0b',&#10;        sound: 'default',&#10;        enableVibrate: true,&#10;        showBadge: true,&#10;      });&#10;    }&#10;&#10;    if (Device.isDevice) {&#10;      const { status: existingStatus } = await Notifications.getPermissionsAsync();&#10;      let finalStatus = existingStatus;&#10;      &#10;      if (existingStatus !== 'granted') {&#10;        const { status } = await Notifications.requestPermissionsAsync({&#10;          ios: {&#10;            allowAlert: true,&#10;            allowBadge: true,&#10;            allowSound: true,&#10;            allowAnnouncements: true,&#10;          },&#10;        });&#10;        finalStatus = status;&#10;      }&#10;      &#10;      if (finalStatus !== 'granted') {&#10;        console.log('Failed to get push token for push notification!');&#10;        return null;&#10;      }&#10;      &#10;      token = (await Notifications.getExpoPushTokenAsync({&#10;        projectId: 'your-project-id' // Optional: Add when you create EAS project&#10;      })).data;&#10;      console.log('Push token obtained:', token);&#10;    } else {&#10;      console.log('Must use physical device for Push Notifications');&#10;      return null;&#10;    }&#10;&#10;    return token;&#10;  }&#10;&#10;  /**&#10;   * Save push token to backend&#10;   */&#10;  async savePushToken(token, authToken) {&#10;    try {&#10;      const response = await fetch(`${API_URL}/push-tokens`, {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;          'Authorization': `Bearer ${authToken}`,&#10;        },&#10;        body: JSON.stringify({&#10;          push_token: token,&#10;          device_type: Platform.OS,&#10;        }),&#10;      });&#10;&#10;      const data = await response.json();&#10;      &#10;      if (data.success) {&#10;        console.log('Push token saved to backend');&#10;        await AsyncStorage.setItem('push_token', token);&#10;      } else {&#10;        console.error('Failed to save push token:', data.message);&#10;      }&#10;&#10;      return data;&#10;    } catch (error) {&#10;      console.error('Error saving push token:', error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Remove push token from backend (on logout)&#10;   */&#10;  async removePushToken(authToken) {&#10;    try {&#10;      const token = await AsyncStorage.getItem('push_token');&#10;      if (!token) return;&#10;&#10;      const response = await fetch(`${API_URL}/push-tokens`, {&#10;        method: 'DELETE',&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;          'Authorization': `Bearer ${authToken}`,&#10;        },&#10;        body: JSON.stringify({&#10;          push_token: token,&#10;        }),&#10;      });&#10;&#10;      const data = await response.json();&#10;      &#10;      if (data.success) {&#10;        console.log('Push token removed from backend');&#10;        await AsyncStorage.removeItem('push_token');&#10;      }&#10;&#10;      return data;&#10;    } catch (error) {&#10;      console.error('Error removing push token:', error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Setup notification listeners&#10;   */&#10;  setupNotificationListeners(onNotificationReceived, onNotificationTapped) {&#10;    // Listener for notifications received while app is in foreground&#10;    const notificationListener = Notifications.addNotificationReceivedListener(notification =&gt; {&#10;      console.log('Notification received:', notification);&#10;      if (onNotificationReceived) {&#10;        onNotificationReceived(notification);&#10;      }&#10;    });&#10;&#10;    // Listener for when user taps on notification&#10;    const responseListener = Notifications.addNotificationResponseReceivedListener(response =&gt; {&#10;      console.log('Notification tapped:', response);&#10;      if (onNotificationTapped) {&#10;        onNotificationTapped(response);&#10;      }&#10;    });&#10;&#10;    return {&#10;      notificationListener,&#10;      responseListener,&#10;    };&#10;  }&#10;&#10;  /**&#10;   * Remove notification listeners&#10;   */&#10;  removeNotificationListeners(listeners) {&#10;    if (listeners.notificationListener) {&#10;      Notifications.removeNotificationSubscription(listeners.notificationListener);&#10;    }&#10;    if (listeners.responseListener) {&#10;      Notifications.removeNotificationSubscription(listeners.responseListener);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Schedule a local notification (for testing)&#10;   */&#10;  async scheduleLocalNotification(title, body, data = {}, seconds = 1) {&#10;    await Notifications.scheduleNotificationAsync({&#10;      content: {&#10;        title,&#10;        body,&#10;        data,&#10;        sound: true,&#10;      },&#10;      trigger: { seconds },&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Get notification permissions status&#10;   */&#10;  async getPermissionsStatus() {&#10;    const { status } = await Notifications.getPermissionsAsync();&#10;    return status;&#10;  }&#10;&#10;  /**&#10;   * Request notification permissions&#10;   */&#10;  async requestPermissions() {&#10;    const { status } = await Notifications.requestPermissionsAsync();&#10;    return status;&#10;  }&#10;}&#10;&#10;export default new PushNotificationService();" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>